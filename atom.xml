<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[劈柴者]]></title>
  <link href="http://ghacker.github.com/atom.xml" rel="self"/>
  <link href="http://ghacker.github.com/"/>
  <updated>2012-07-08T19:12:23+08:00</updated>
  <id>http://ghacker.github.com/</id>
  <author>
    <name><![CDATA[或与非]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Haskell 文学编程系统中的 tangle 工具的实现]]></title>
    <link href="http://ghacker.github.com/blog/2012/07/08/htangle/"/>
    <updated>2012-07-08T19:09:00+08:00</updated>
    <id>http://ghacker.github.com/blog/2012/07/08/htangle</id>
    <content type="html"><![CDATA[<p>Haskell 语言自身便是一种半文学编程系统，因为它的函数可以按照人类的思维逻辑进行组织，但是它缺乏 Knuth WEB 中\quotation{节}的灵活性与可读性。Haskell 文学编程系统这个项目（下面简称 HWEB）的主要目的就是基于 Haskell 与 \CONTEXT\ MkIV 排版语言为 Haskell 实现一个完备的文学编程系统。</p>

<!--more-->


<p>HWEB 程序的描述语言类似于非常轻量级的标记语言——Markdown，但是在普通的文本区域皆可自由的插入 \CONTEXT 命令。</p>

<h2>HWEB 程序的\quotation{节}</h2>

<p>\quotation{节}可将一个 HWEB 程序划分为树形结构。利用这一结构，我们就可以像撰写一份文档那样来写一个 HWEB 程序。</p>

<p>每一节都是以一个或多个连续的 \type{#} 符号开始，节的层次性体现于 \type{#} 符号的个数。例如 \type{###} 表示第三层的节。</p>

<p>注意，每一节的结束就是下一节的开始。</p>

<p>尾随 \type{#} 符号序列的是节的标题，其终止符是换行符。节的标题可以为空，这样在产生的 \CONTEXT\ 文档中就会得到只有序号但是没有标题的小节。</p>

<p>每一节均由两个部分构成，自然语言部分与 Haskell 语言部分，它们各自的职能是：</p>

<ul>
<li>自然语言部分：使用人类语言来描述这一节所实现的程序功能或程序逻辑；</li>
<li>Haskell 语言部分：具体的 Haskell 代码片段或者 HWEB 宏。</li>
</ul>


<p>这两个部分中的任一个皆可为空，但是如果它们都存在，那么自然语言部分必须要先于 Haskell 语言部分。</p>

<h2>htangle 的自举实现过程</h2>

<p>为了保证 htangle 的实现过程是一个自举过程，也就是说用 HWEB 程序来写 htangle 自身。这个过程的需要一个起源。</p>

<p>在起源阶段，虽然 htangle 工具的实现是基于 HWEB 代码实现，但是 Haskell 代码需要人工从 HWEB 代码中抽取，只有如此方可得到第一个可用的 htangle。</p>

<p>一旦有了第一个 htangle，那么它便是当前可用的 htangle。它的下一个版本可以通过 HWEB 实现，然后利用既有的 htangle 工具并配合少量的人工从 HWEB 代码中抽取得到新版本 htangle 的 Haskell 代码，对其编译后即可得到一个新的 htangle 工具。</p>

<p>这个迭代过程，便能够使得 htangle 一直处于进化状态，等到我厌倦之时，也就是这个迭代过程收敛之时。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[48 小时写一个属于你的 Scheme 解释器]]></title>
    <link href="http://ghacker.github.com/blog/2012/05/01/write-yourself-a-scheme-in-48-hours/"/>
    <updated>2012-05-01T17:04:00+08:00</updated>
    <id>http://ghacker.github.com/blog/2012/05/01/write-yourself-a-scheme-in-48-hours</id>
    <content type="html"><![CDATA[<p>原文见：<a href="http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">Write Yourself a Scheme in 48 Hours</a>。本文档对原文档的更新不作出跟随的承诺。</p>

<p>48 小时写一个属于你的 Scheme 解释器，这是一份重要的 Haskell 编程指南，由 Jonathan Tang 所写。感谢 Jonathan 对该文档的授权。贡献者们可以自由修改这份指南的 Wiki 版本！</p>

<!--more-->


<h2>〇、 概览</h2>

<p>网络上的大部分 Haskell 指南似乎都是采用语言参考手册的方式讲授的。它们向你展示语法、一点语言的构造思想，并教你在 Haskell 解释器中构建一些简单的函数。而真正“困难的东西”，即如何写一个有用的函数式程序往往是放在了最后才讲，有的指南则完全忽略这一点。</p>

<p>这份指南采取了不同的方式。你将会从一个命令行参数解析程序开始，逐步到写出一个完全函数式的 Scheme 解释器。这里所说的 Scheme 是 <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML">R<sup>5</sup>RS Scheme</a> 的一个经过适当裁剪的子集。基于这种方式，你将会掌握 Haskell 的 I/O、可变状态、动态类型、错误处理以及解析功能。待读完这份教程之后，你便会对 Haskell 与 Scheme 相当的熟稔。</p>

<p>这份指南的主要受众有两类：</p>

<ul>
<li>已对 Lisp 或 Scheme 有所了解并且想学习 Haskell 的人群</li>
<li>对编程一无所知但是具备深厚的背景知识并且熟悉计算机的人群</li>
</ul>


<p>当我掩盖 Scheme 的一些细节以及一般性的编程概念而主要关注 Haskell 之时，第二类人群可能会发现这是一个挑战。对于这一问题，像 <a href="http://mitpress.mit.edu/sicp/full-text/book/book.html">Structure and Interpretation of Computer Programs</a> 或 <a href="http://www.ccs.neu.edu/home/matthias/BTLS/">The Little Schemer</a> 这样优秀的教材可能会很有帮助。</p>

<p>不过，对于像 C、Java 或 Python 这些过程式或面向对象式的语言的用户应当小心：你需要忘掉你对于编程所积累的大部分经验。与这些语言相比，Haskell 是完全不同的，并且编程方式也是不同的。最好是秉持白板一样并且尽力不与命令式语言进行比较的心态步入这份指南，因为那些语言中的许多概念（类、函数、return）在 Haskell 中有着截然不同的含义。</p>

<p>因为每一章都是构建于前一章所写的代码的基础之上，最好是按次序阅读各章。</p>

<p>这份指南假定你使用的 Haskell 编译器是 <a href="http://www.haskell.org/ghc/">GHC</a>。其他编译器，例如 <a href="http://www.haskell.org/hugs/">Hugs</a> 兴许也行，但是没有经过测试，可能需要你安装一些附加的库。</p>

<p>源代码可从这里下载：<a href="http://jonathan.tang.name/files/scheme_in_48/code/">代码清单</a>。</p>

<h2>一、 编译与运行</h2>

<p>略过如何安装 GHC 以及如何编写 Haskell 代码的废话。现在是开始写你的第一个 Haskell 程序的时间。这个程序将会从命令行读取一个名字，然后打印一句问候。创建一个以 <code>.hs</code> 作为文件名结尾的文件，内容如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">module</span> <span class="nn">Main</span> <span class="kr">where</span>
</span><span class='line'><span class="kr">import</span> <span class="nn">System.Environment</span>
</span><span class='line'>
</span><span class='line'><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
</span><span class='line'><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">args</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
</span><span class='line'>          <span class="n">putStrLn</span> <span class="p">(</span><span class="s">&quot;Hello, &quot;</span> <span class="o">++</span> <span class="n">args</span> <span class="o">!!</span> <span class="mi">0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>让我们在这份代码中游览一番。前两行代码表明：我们将要创建一个名为 <code>Main</code> 的模块，这个模块又导入了 <code>System</code> 模块。每个 Haskell 程序都会以一个叫做 <code>main</code> 的动作开始，这个动作位于一个名为 <code>Main</code> 的模块。这个模块可以导入其他模块，但只有它用于供编译器生成可执行文件。Haskell 是大小写敏感的：模块名总是以大写字母开头。</p>

<p><code>main :: IO ()</code> 行是类型声明：它表明了 <code>main</code> 的类型是 <code>IO ()</code>，而这种类型的含义是运送一个单元（unit）类型 <code>()</code> 的值的 IO 动作。单元类型只有一个值，即 <code>()</code>，表示不承载任何信息。Haskell 的类型声明是可选的：编译器可以自动识别出类型，只有当它们与你所指定的类型不符时，编译器才会报错。在这份指南中，为了代码的清晰，我会显式的指明所有的类型声明。如果你在家中抄写代码作为练习的时候，你可能想省略它们以节省码字时间。</p>

<p><code>IO</code> 类型是一种叫做单子（Monad）的东西的一个实例。单子这个名字听起来有些吓人，但它所表示的概念并不太吓人。简单的说，单子是描述“我们将会以某种特定的方式运送或组合一些值及其相关的附加信息，这些附加信息对于大部分函数而言无关紧要”的一种方式。我们如何运送值的附加信息以及如何将这些值组合起来决定了特定的单子类型；值本身可能会有变化或者经由常规的函数（被动作调用）从一种类型转化为另一种类型，它不会影响到其外围附加的那些东西，但是值的变化必须要在同一条管道（值的传播机制）中进行。</p>

<p>对于 <code>IO ()</code> 类型，“附加信息”就是待被执行的 IO 动作，该动作的执行需要借助它所承载的值以及那个类型为 <code>()</code>的空值。<code>IO [String]</code> 与 <code>IO ()</code> 是伴随不同基本类型的同一单子类型，意味着它们都是作用于不同类型的值并且传递这些值的 IO 动作。单子化的值与封装在其内的基本值组合而成的东西通常被称为“动作”（其实只有状态单子有这样的称谓），因为理解 IO 单子最容易的方式是动作的序列化，其中每个动作都可能会影响外部世界。</p>

<p>Haskell 是一种函数式语言：它不是向计算机提供一个待被执行的指令序列，而是要给出一个充满定义的集合，这个集合描述了如何执行它可能需要的每个函数。这些定义是通过各种动作的组合以及函数而实现的。编译器能够计算出一个可将一切东西整合到一起的执行路径。</p>

<p>这些定义，就像一个一个方程。在左侧定义一个名字，在其之后安置一个或多个可以绑定变量的模式（见<a href="http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_1">后文</a>）。这些方程在行为上就像普通的代数方程那样：你总是可以在程序代码中使用右侧来替换左侧，所得结果也必定相同。这种性质被称为“引用透明”，它使得 Haskell 程序的构思要较其他语言更为容易。</p>

<p>我们该如何定义 <code>main</code> 动作？我们知道它肯定是一个 <code>IO ()</code> 动作，其任务是读取命令行参数，然后作一些输出，最终生成 <code>()</code> 类型的值。</p>

<p>创建一个 IO 动作有两种方式：</p>

<ol>
<li>使用 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$tMonad">return</a> 函数提升一个普通的值使之进入 IO 单子；</li>
<li>组合两个既有的 IO 动作。</li>
</ol>


<p>因为我们想做的是两件事，所以我们采取第二种方式。内建的动作 <a href="http://www.haskell.org/ghc/docs/6.4/html/libraries/base/System.Environment.html#v%3AgetArgs">getArgs</a> 可以读取命令行参数并将其作为字符串列表的形式进行传送。内建函数 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$vputStrLn">putStrLn</a> 可以接受一个字符串然后创建一个可以将字串写入控制台的动作。</p>

<p>为了组合这些动作，我们可以使用 do-块，它是由 do 之后的第一个非空字符起始的一系列行构成。每一行的形式不外乎：</p>

<ol>
<li>name &lt;- action1</li>
<li>action2</li>
</ol>


<p>第一种形式是将 action1 的结果绑定到 name 以待后面的动作使用。例如，如果 action1 的类型是 <code>IO [String]</code>（一个返回字符串列表的 IO 动作，像 getArgs），那么在后续的所有动作中 name 会一直以绑定到字符串列表的形式被“绑定”操作符 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$tMonad"><code>&gt;&gt;=</code></a> 传递。对于不同的单子，绑定操作符有着不同的语意：对于 IO 单子，它会顺序执行动作，以实现动作结果所产生的任何对外部的负面影响。因为这种组合机制依赖于所使用的特定的单子，你无法将不同单子类型的动作在一个只能被 IO 单子使用的 do-块中混杂使用。</p>

<p>当然，这些动作本身可以调用函数或者复杂的表达式并传出它们的结果（通过 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$tMonad">return</a> 函数或者其他可以最终可以做此事的函数）。本章的示例中，我们首先提取参数值列表的第一个元素（索引号为 0 的元素，即 <code>args !! 0</code>），然后使用 <code>("Hello, " ++)</code> 将其连接到字符串 &#8220;Hello, &#8221; 的尾部，最终将字串传送给 <code>putStrLn</code>，由它创建一个新的 IO 动作。这个过程就构成了 do-块的语句序列。</p>

<p>所创建的那个新的动作，它组合了上述的动作序列，被存储为 <code>IO ()</code> 类型的标识符 <code>main</code>。Haskell 系统会注意到这个定义，并执行其中的动作。</p>

<p>在 Haskell 中，字符串是字符列表，因此你可以使用任何一个列表函数或操作符来处理它们。下面是一些标准操作符及其优先级的表格。</p>

<div style="width:100%; text-align:center">
<table style="margin:0px auto;">
<tbody><tr>
<th style="text-align:center;">操作符</th>
<th style="text-align:center;">优先级</th>
<th style="text-align:center;">结合性</th>
<th style="text-align:center;">含义</th>
</tr>
<tr>
<td>.</td>
<td>9</td>
<td>右</td>
<td>函数复合</td>
</tr>
<tr>
<td>!!</td>
<td>9</td>
<td>左</td>
<td>列表索引</td>
</tr>
<tr>
<td>^, ^^, **</td>
<td>8</td>
<td>右</td>
<td>幂运算（整型、分数与浮点数）</td>
</tr>
<tr>
<td>*, /</td>
<td>7</td>
<td>左</td>
<td>乘、除</td>
</tr>
<tr>
<td>+, -</td>
<td>6</td>
<td>左</td>
<td>加、减</td>
</tr>
<tr>
<td>:</td>
<td>5</td>
<td>右</td>
<td>列表构造符</td>
</tr>
<tr>
<td>++</td>
<td>5</td>
<td>右</td>
<td>列表联接符</td>
</tr>
<tr>
<td>`elem`, `notElem`</td>
<td>4</td>
<td>左</td>
<td>列表成员关系</td>
</tr>
<tr>
<td>==, /=, &lt;, &lt;=, &gt;=,&gt;</td>
<td>4</td>
<td>左</td>
<td>等于、不等于及其他相关操作符</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>3</td>
<td>右</td>
<td>逻辑与</td>
</tr>
<tr>
<td>||</td>
<td>2</td>
<td>右</td>
<td>逻辑或</td>
</tr>
<tr>
<td>&gt;&gt;, &gt;&gt;=</td>
<td>1</td>
<td>左</td>
<td>单子绑定（构建管道将值传递给后面的函数）</td>
</tr>
<tr>
<td>=&lt;&lt;</td>
<td>1</td>
<td>右</td>
<td>逆向的单子绑定（与上面那个相同，只不过参数值的位置相反）</td>
</tr>
<tr>
<td>$</td>
<td>0</td>
<td>右</td>
<td>中缀函数应用符（与 &#8220;f x&#8221; 相同，但是将结合方向由左向转化为右向）</td>
</tr>
</tbody></table>
</div>


<p>要编译与运行本章的这个程序，可以像下面这样做：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ghc -o hello_you --make listing2.hs
</span><span class='line'><span class="nv">$ </span>./hello_you Jonathan
</span><span class='line'>Hello, Jonathan
</span></code></pre></td></tr></table></div></figure>


<p><code>-o</code> 选项设定了所要创建的可执行文件名，然后再指定所要编译的 Haskell 源文件名。</p>

<h3>习题</h3>

<ol>
<li>修改本章的程序，使之可从命令行读取 2 个参数值，然后将它们打印出来。</li>
<li>修改本章的程序，使之可以对 2 个参数值完成一个简单的代数运算并打印出结果。你可以使用 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$vread"><code>read</code></a> 函数将字符串转化为数字，使用 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$tShow"><code>show</code></a> 函数将数字转回字符串。可以再试试其他运算。</li>
<li><code>getLine</code> 是一个 IO 动作，它从控制台读取一行文本然后将其作为字符串返回。修改本章的程序，使之可以提示需要一个名字，读取这个名字，然后打印出来，而不是通过命令行参数值的形式输入。</li>
</ol>


<h2>二、 解析</h2>

<h3>写一个简单的解析器</h3>

<p>现在，让我们尝试写一个简单的解析器。这需要用到 <a href="http://www.cs.uu.nl/~daan/download/parsec/parsec.html">Parsec</a> 库。</p>

<p>首先在 import 部分添加这样一行代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">import</span> <span class="nn">Text.ParserCombinators.Parsec</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">spaces</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这行代码使得我们可以使用 Parsec 库中除 spaces 函数之外的函数。之所以要排除 spaces 函数，是因为它的名字会与我们之后定义的一个函数的名字冲突。</p>

<p>下面我们要定义一个能够识别 Scheme 标识符中一些符号的解析器：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">symbol</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">Char</span>
</span><span class='line'><span class="nf">symbol</span> <span class="ow">=</span> <span class="n">oneOf</span> <span class="s">&quot;!#$%&amp;|*+-/:&lt;=&gt;?@^_~&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这又是一个单子的示例：此时所隐藏的“附加信息”是输入流的当前位置、回溯记录、第一个集合及后续集合等等。Parsec 可以为我们管理这一切。我们只需使用 Parsec 库函数 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#oneOf"><code>oneOf</code></a>，它可以从传入的任意字符串中识别出单个字符。Parsec 提供了许多预定义的解析器：例如作为库函数的 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#letter"><code>letter</code></a> 与 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#digit"><code>digit</code></a>。你将会看到这些基本的解析器可以组合为更为复杂的解析器。</p>

<p>可以定义一个函数来调用我们的解析器并处理任何可能的错误：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">readExpr</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</span><span class='line'><span class="nf">readExpr</span> <span class="n">input</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">parse</span> <span class="n">symbol</span> <span class="s">&quot;lisp&quot;</span> <span class="n">input</span> <span class="kr">of</span>
</span><span class='line'>    <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="s">&quot;No match: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">err</span>
</span><span class='line'>    <span class="kt">Right</span> <span class="n">val</span> <span class="ow">-&gt;</span> <span class="s">&quot;Found value&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>看一下类型签名，<code>readExpr</code> 是一个从字符串到字符串的函数。我们将参数命名为 <code>input</code>，然后将其传递于上面定义的 <code>symbol</code> 解析器直至 Parsec 函数 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#parse"><code>parse</code></a>。<code>parse</code> 的第二个参数是 <code>input</code> 字符串的名字，主要是在错误信息中使用。</p>

<p><code>parse</code> 能够返回解析所得的值或者错误，因此我们需要处理出错的情况。根据 Haskell 惯例，Parsec 返回一个 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$tEither"><code>Either</code></a> 类型的值，它使用 <code>Left</code> 构造子表示一个错误，使用 <code>Right</code> 值构造子表示一个正常的值。</p>

<p>我们使用 <code>case...of</code> 结构来匹配 <code>parse</code> 的结果，从而形成可选分支。如果我们得到的是一个 <code>Left</code> 值（错误），那么就将值（错误信息）绑定到 <code>err</code>，然后返回“No match”以及错误信息字符串。如果我们得到的是 <code>Right</code> 值，我们就值绑定到 <code>val</code> 并且忽略它，然后返回字符串“Found value”。</p>

<p><code>case...of</code> 结构是模式匹配的一个例子，更多的细节在<a href="http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Evaluation,_Part_1#Beginnings_of_an_evaluator:_Primitives">后文</a>讲述。</p>

<p>最后，我们需要修改 <code>main</code> 函数使之调用 <code>readExpr</code> 并打印出结果：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
</span><span class='line'><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">args</span> <span class="ow">&lt;-</span> <span class="n">getArgs</span>
</span><span class='line'>          <span class="n">putStrLn</span> <span class="p">(</span><span class="n">readExpr</span> <span class="p">(</span><span class="n">args</span> <span class="o">!!</span> <span class="mi">0</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了编译和运行这个程序，你需要在命令行中设定 <code>-package parsec</code> 选项，否则会出现连接错误。例如：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ghc -package parsec -o simple_parser listing3.1.hs
</span><span class='line'><span class="o">[</span>1 of 1<span class="o">]</span> Compiling Main             <span class="o">(</span> sec.hs, sec.o <span class="o">)</span>
</span><span class='line'>Linking simple_parser ...
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="err">$</span>
</span><span class='line'>Found value
</span><span class='line'><span class="nv">$ </span>./simple_parser a
</span><span class='line'>No match: <span class="s2">&quot;lisp&quot;</span> <span class="o">(</span>line 1, column 1<span class="o">)</span>:
</span><span class='line'>unexpected <span class="s2">&quot;a&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>空白符</h3>

<p>下面将会对我们的解析器进行一些改进，使之能逐步识别出更为复杂的表达式。当前的解析器在遇到所解析符号之前有空白符的时候会挂掉：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>./simple_parser <span class="s2">&quot;    %&quot;</span>
</span><span class='line'>No match: <span class="s2">&quot;lisp&quot;</span> <span class="o">(</span>line 1, column 1<span class="o">)</span>:
</span><span class='line'>unexpected <span class="s2">&quot; &quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们要解决这个问题，即忽略空白符。</p>

<p>首先，定义一个能识别任意数量空白字符的解析器。顺便说一下，这就是为什么我们在导入 Parsec 模块时使用 <code>hiding (spaces)</code> 从句的原因：该库中已经有了一个叫做 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#spaces"><code>spaces</code></a> 的函数，但是它不能满足我们的需求（实际上库中有个叫做 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#lexeme"><code>lexeme</code></a> 的解析器可以满足我们的要求，但是出于教学的目的，我们不打算使用它）。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">spaces</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="nb">()</span>
</span><span class='line'><span class="nf">spaces</span> <span class="ow">=</span> <span class="n">skipMany1</span> <span class="n">space</span>
</span></code></pre></td></tr></table></div></figure>


<p>就像函数可以作为参数传递给函数一样，动作也可以这样。这里我们向 Parser 动作 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#skipMany1"><code>skipMany1</code></a> 传递了 Parser 动作 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#space"><code>space</code></a>，这样便可得到一个可以识别一个或多个空格的解析器。</p>

<p>现在，我们的解析函数需要修改一下，让它用上这个新的解析器，改动如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">readExpr</span> <span class="n">input</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">parse</span> <span class="p">(</span><span class="n">spaces</span> <span class="o">&gt;&gt;</span> <span class="n">symbol</span><span class="p">)</span> <span class="s">&quot;lisp&quot;</span> <span class="n">input</span> <span class="kr">of</span>
</span><span class='line'>  <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="s">&quot;No match: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">err</span>
</span><span class='line'>  <span class="kt">Right</span> <span class="n">val</span> <span class="ow">-&gt;</span> <span class="s">&quot;Found value&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上一章已经接触过了绑定操作符 <code>&gt;&gt;</code>，它是用于在幕后组合 do-块语句的。在这里，我们显式的应用它来组合空白符解析器 <code>spaces</code> 与符号解析器 <code>symbol</code>。不过 Parser 单子的绑定与 IO 单子的绑定是截然不同的。在 Parser 单子中，绑定的含义是“尝试匹配第一个解析器，然后对余下的输入信息尝试匹配第二个解析器，如果两个都失败的话，那就失败”。不同的单子的绑定机制通常也是显著不同的；绑定的意图就是提供一种结构化计算的通用方式，因此需要有一种海纳百川以适应不同计算类型的气度。通过阅读有关单子方面的文档便可以知道它究竟做了什么（译者注：推荐阅读“<a href="http://ghacker.org/blog/2012/04/13/monads-for-the-curious-porgrammer/">单子求索</a>”）。</p>

<p>编译并运行现在的代码。注意因为我们基于 <code>skipMany1</code> 定义的 <code>spaces</code>，它不能想之前那样处理单个字符的输入，现在你需要在待解析的符号之前冠以一些空白字符作为输入。下面看一下它是否有用：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ghc -package parsec -o simple_parser listing3.2.hs
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="s2">&quot;    %&quot;</span>
</span><span class='line'>Found value
</span><span class='line'><span class="nv">$ </span>./simple_parser %
</span><span class='line'>No match: <span class="s2">&quot;lisp&quot;</span> <span class="o">(</span>line 1, column 1<span class="o">)</span>:
</span><span class='line'>unexpected <span class="s2">&quot;%&quot;</span>
</span><span class='line'>expecting space
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="s2">&quot;    abc&quot;</span>
</span><span class='line'>No match: <span class="s2">&quot;lisp&quot;</span> <span class="o">(</span>line 1, column 5<span class="o">)</span>:
</span><span class='line'>unexpected <span class="s2">&quot;a&quot;</span>
</span><span class='line'>expecting space
</span></code></pre></td></tr></table></div></figure>


<h3>返回值</h3>

<p>到现在为止，解析器还没有做太多的事情——它只能告诉我们一个给定的字符串能不能被识别。我们想让它做更多的事情：将输入转换为一种易于遍历的数据结构。本节，我们要学习如何定义一种数据类型以及如何修改解析器使之返回这种数据类型。</p>

<p>首先，我们需要定义一种可以承载任何 Lisp 值的数据类型：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">LispVal</span> <span class="ow">=</span> <span class="kt">Atom</span> <span class="kt">String</span>
</span><span class='line'>             <span class="o">|</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">]</span>
</span><span class='line'>             <span class="o">|</span> <span class="kt">DottedList</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">]</span> <span class="kt">LispVal</span>
</span><span class='line'>             <span class="o">|</span> <span class="kt">Number</span> <span class="kt">Integer</span>
</span><span class='line'>             <span class="o">|</span> <span class="kt">String</span> <span class="kt">String</span>
</span><span class='line'>             <span class="o">|</span> <span class="kt">Bool</span> <span class="kt">Bool</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是代数数据类型的一个示例：它定义了一个 LispVal 类型的变量所能承载的所有可能值的集合。每个选项（称为构造子，以 <code>|</code> 隔开）包含了一个值构造子的名称及其所能承纳的数据类型。在这个例子中，一个 LispVal 值可能是：</p>

<ol>
<li>原子：承纳一个命名该原子的字符串</li>
<li>列表：承纳其他 LispVal 值的列表（Haskell 的列表采用中括号表示）；也被称为正规列表（Proper List）</li>
<li>加点列表：表示一种 Scheme 格式 `(a b . c)；也被称为非正规列表（Improper List）。它承纳一组元素但是不包含最后那个元素，然后将最后那个元素作为另外一个域</li>
<li>数字：承纳 Haskell 的整型数</li>
<li>字符串：承纳 Haskell 的字符串</li>
<li>布尔值：承纳 Haskell 的布尔值</li>
</ol>


<p>构造子与类型处于不同的命名空间，因此你可以让构造子与类型命同名，但它们必须以大写字母开头。</p>

<p>下一步，我们添加一些解析函数来创建这些类型的值。先构造字符串，即构造以双引号囊括的非引号字符的值：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">parseString</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">parseString</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">char</span> <span class="sc">&#39;&quot;&#39;</span>
</span><span class='line'>                 <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="p">(</span><span class="n">noneOf</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">)</span>
</span><span class='line'>                 <span class="n">char</span> <span class="sc">&#39;&quot;&#39;</span>
</span><span class='line'>                 <span class="n">return</span> <span class="o">$</span> <span class="kt">String</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我们又用回了 do-块来替代 <code>&gt;&gt;</code> 操作符。这是因为我们要检出解析后的值（由 <code>many (noneOf "\"")</code> 返回的值）并进行处理，同时交叉着其他的解析操作。通常情况下，如果动作没有返回值的话，就使用 <code>&gt;&gt;</code>，如果要将一个动作的返回值立刻传递给下一个动作，那么就使用 <code>&gt;&gt;=</code>，而 do-块可以包容这两种情况。</p>

<p>一旦完成了字符串的解析并且通过 <code>many</code> 获得了 Haskell 字符串，便可使用 <code>String</code> 构造子（来自 LispVal 数据类型）将其转化为 LispVal 值。代数数据类型的每一个构造子都像一个函数，可以将参数值转化为代数数据类型的值。它也可作为模式匹配表达式的左部来使用，前面已经有了这样的例子，即使用 <code>Either</code> 数据类型的两个构造子来匹配解析器的结果。</p>

<p>最后我们应用内建函数 [<code>return</code>] 将 LispVal 值提升为 Parser 单子。要记住，do-块的每一行必须有相同的类型，但是 <code>String</code> 构造子返回结果的类型是 LispVal。<code>return</code> 可以将 LispVal 类型的值封装到 Parsec 动作中。这样，<code>parseString</code> 这个动作的类型就是 <code>Parser LispVal</code>。</p>

<p><code>$</code> 操作符是中缀函数应用。实际上 <code>return $ String x</code> 与 <code>return (String x)</code> 是等价的。由于 <code>$</code> 是向右结合的，因此它的作用就是消除一些括号。既然 <code>$</code> 是一个操作符，你可以像使用函数那样的来使用它：将它作为参数值传递、部分应用等，在这方面 <code>$</code> 的功能类似 Lisp 函数 <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.4"><code>apply</code></a>。</p>

<p>下面来看 Scheme 变量的解析。一个<a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-5.html#%_sec_2.1">原子</a> 是由一个字母或符号及其后尾随的任意数量的字符、数字或符号构成：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">parseAtom</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">parseAtom</span> <span class="ow">=</span> <span class="kr">do</span> <span class="n">first</span> <span class="ow">&lt;-</span> <span class="n">letter</span> <span class="o">&lt;|&gt;</span> <span class="n">symbol</span>
</span><span class='line'>               <span class="n">rest</span> <span class="ow">&lt;-</span> <span class="n">many</span> <span class="p">(</span><span class="n">letter</span> <span class="o">&lt;|&gt;</span> <span class="n">digit</span> <span class="o">&lt;|&gt;</span> <span class="n">symbol</span><span class="p">)</span>
</span><span class='line'>               <span class="kr">let</span> <span class="n">atom</span> <span class="ow">=</span> <span class="n">first</span><span class="kt">:</span><span class="n">rest</span>
</span><span class='line'>               <span class="n">return</span> <span class="o">$</span> <span class="kr">case</span> <span class="n">atom</span> <span class="kr">of</span> <span class="s">&quot;#t&quot;</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="kt">True</span>
</span><span class='line'>                                     <span class="s">&quot;#f&quot;</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span> <span class="kt">False</span>
</span><span class='line'>                                     <span class="kr">_</span>    <span class="ow">-&gt;</span> <span class="kt">Atom</span> <span class="n">atom</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们又引入了一个 Parsec 的组合子——选择操作符 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#or"><code>&lt;|&gt;</code></a>。它会尝试执行第一个解析器，如果失败的话，那么就执行第二个；如果两个解析器都成功的话，它便返回解析器所返回的值。第一个解析器必须要在消耗任何输入之前失败：后面我们可以看到如何实现回溯。</p>

<p>一旦读取了第一个字符以及原子的剩余字符，我们必须将它们归并到一起。<code>let</code> 语句定义了一个新变量 <code>atom</code>。我们使用列表构造子 <code>:</code> 来实现 <code>atom</code> 的定义。不使用 <code>:</code> 的话，也可以使用连接操作符 <code>++</code>，例如 <code>[first] ++ rest</code>；因为 <code>first</code> 是字符，因此我们需要使用方括号将它转化为单元素列表。</p>

<p>然后我们使用 case 表达式根据用于表示 true 与 false 的字符串来判定是哪一种 LispVal 值被创建和返回。下划线 <code>_</code> 候选项是为了可阅读性而搞的小把戏：case 块会持续行进至 <code>_</code> 的情况（或者所有情况都会失败，最终导致 case 表达式失败），可以将 <code>_</code> 想像成通配符。因此如果代码落入 <code>_</code> 的情况，它总是会被匹配并且返回 <code>atom</code> 值。</p>

<p>最后，我们再创建一个数字的解析器。它展示了处理单子值的又一种方式：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">parseNumber</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">parseNumber</span> <span class="ow">=</span> <span class="n">liftM</span> <span class="p">(</span><span class="kt">Number</span> <span class="o">.</span> <span class="n">read</span><span class="p">)</span> <span class="o">$</span> <span class="n">many1</span> <span class="n">digit</span>
</span></code></pre></td></tr></table></div></figure>


<p>上述代码应该从右向左阅读，因为 <code>$</code> 与函数复合符 <code>.</code> 都是向右结合的。Parsec 的组合子 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#many1"><code>many1</code></a> 可以应用其参数值（解析器）一次或更多次，因此它可以匹配一个或多个数字。我们是想基于匹配所得字符串创建一个 LispVal 的数值，但是在类型上有些不匹配，需要使用内建函数 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$vread"><code>read</code></a> 将字符串转换为数字，然后将数字传递给 <code>Number</code> 构造子从而得到 LispVal 值。函数复合操作符 <code>.</code> 可以创建一个函数，该函数会应用右侧的参数值，然后将结果传递给左侧的参数值，因此我们使用它来组合两个函数。</p>

<p>不幸的是，<code>many1 digit</code> 的结果的类型实际上是 <code>Parser String</code>，因此我们组合的 <code>Number . read</code> 无法操作它。我们需要一个可以操作隐含于单子内部的值但所得结果是 <code>Parser LispVal</code> 类型的值的方法。标准函数 <code>liftM</code> 就是为了这个问题应运而生，因此我们对 <code>Number . read</code> 函数应用 <code>liftM</code>，然后将其作用于我们的解析器。</p>

<p>为了使用 <code>liftM</code>，我们需要导入单子模块：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">import</span> <span class="nn">Control.Monad</span>
</span></code></pre></td></tr></table></div></figure>


<p>重度依赖函数复合、函数应用以及将函数传递给函数，这种编程风格在 Haskell 代码中非常普遍。将一些中间步骤分散为函数然后以各种方式组合起来，这种方式经常可以让你以单行代码就可以表示非常复杂的运算。不幸的是，这意味着你经常要从右向左阅读代码，并且保持对类型的警醒。这种编程风格会贯穿这份指南的剩余部分，因此希望你能很好的适应它。</p>

<p>现在让我们创建一个可以接受字符串、数字或原子的解析器：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">parseExpr</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">parseExpr</span> <span class="ow">=</span> <span class="n">parseAtom</span>
</span><span class='line'>            <span class="o">&lt;|&gt;</span> <span class="n">parseString</span>
</span><span class='line'>            <span class="o">&lt;|&gt;</span> <span class="n">parseNumber</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后修改 <code>readExpr</code> 使之可以调用我们新的解析器：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">readExpr</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</span><span class='line'><span class="nf">readExpr</span> <span class="n">input</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">parse</span> <span class="n">parseExpr</span> <span class="s">&quot;lisp&quot;</span> <span class="n">input</span> <span class="kr">of</span>
</span><span class='line'>  <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="s">&quot;No match: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">err</span>
</span><span class='line'>  <span class="kt">Right</span> <span class="n">val</span> <span class="ow">-&gt;</span> <span class="s">&quot;Found value&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译并运行现在的代码，你会注意到它可以接受任意数字、字符串或符号，其他格式的字符串则不行：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ghc -package parsec -o simple_parser listing3.3.hs
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="s2">&quot;\&quot;this is a string\&quot;&quot;</span>
</span><span class='line'>Found value
</span><span class='line'><span class="nv">$ </span>./simple_parser 25
</span><span class='line'>Found value
</span><span class='line'><span class="nv">$ </span>./simple_parser symbol
</span><span class='line'>Found value
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="o">(</span>symbol<span class="o">)</span>
</span><span class='line'>-bash: syntax error near unexpected token <span class="sb">`</span>symbol<span class="err">&#39;</span>
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="s2">&quot;(symbol)&quot;</span>
</span><span class='line'>No match: <span class="s2">&quot;lisp&quot;</span> <span class="o">(</span>line 1, column 1<span class="o">)</span>:
</span><span class='line'>unexpected <span class="s2">&quot;(&quot;</span>
</span><span class='line'>expecting letter, <span class="s2">&quot;\&quot;&quot;</span> or digit
</span></code></pre></td></tr></table></div></figure>


<h3>练习</h3>

<ol>
<li>重写 <code>parseNumber</code>，使用

<ul>
<li>do-表达式</li>
<li><code>&gt;&gt;=</code> 的显式序列</li>
</ul>
</li>
<li>我们所用的字串不是 <a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.5">R<sup>5</sup>RS</a> 兼容的，因为它们不支持字符串内部引号的逃逸。你可能想使用一个新的解析器来替换 <code>noneOf "\""</code>，这个新解析器可以接受非引号字符或者反斜线后跟随引号的转义</li>
<li>修改上一个练习的答案，使之支持 <code>\n, \r, \t, \\</code> 以及其他所需的转义符</li>
<li>修改 <code>parseNumber</code> 使之支持<a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.2.4">Scheme 不同基底标准</a>。<a href="http://www.haskell.org/onlinereport/numeric.html#sect14"><code>readOct</code> 与 <code>readHex</code></a> 可能对你会有帮助</li>
<li>为 LispVal 添加一个字符构造子，并创建一个 R<sup>5</sup>RS 定义的<a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.4">字符字面值</a>的解析器</li>
<li>为 LispVal 添加一个浮点数构造子，使之支持 R<sup>5</sup>RS 的<a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.2.4">十进制</a>语法。Haskell 函数 <a href="http://www.haskell.org/onlinereport/numeric.html#sect14">readFloat</a> 可能会有用</li>
<li>添加支持 Scheme 数字类型的数据类型和解析器的<a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.2.1">完全数字塔</a>。Haskell 有许多内建类型可以表示其中的大部分类型；请检视 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$tNum">Prelude</a>。对于那些无法直接表示的类型，你可以定义一些复合类型来表示，例如将有理数表示为分子和分母，将复数表示为实部和虚部</li>
</ol>


<h3>递归解析器：添加列表、加点列表以及引用数据的支持</h3>

<p>下面，我们要为我们的 Scheme 解释器添加更多的解析器动作。首先从使得 Lisp 扬名的括号形式的列表开始：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">parseList</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">parseList</span> <span class="ow">=</span> <span class="n">liftM</span> <span class="kt">List</span> <span class="o">$</span> <span class="n">sepBy</span> <span class="n">parseExpr</span> <span class="n">spaces</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个解析器很像 <code>parseNumber</code>。首先解析一串由空白符分割的表达式（<code>sepBy parseExpr spaces</code>），然后在 Parse 单子中应用 List 构造子产生 LispVal 值。要注意我们将 <code>parseExpr</code> 传递给了 <a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#sepBy"><code>sepBy</code></a>，尽管它是我们自己写的一个动作。</p>

<p>加点列表解析器实现起来要更复杂一些，但是所用的概念则是我们已经熟悉的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">parseDottedList</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">parseDottedList</span> <span class="ow">=</span> <span class="kr">do</span>
</span><span class='line'>    <span class="n">head</span> <span class="ow">&lt;-</span> <span class="n">endBy</span> <span class="n">parseExpr</span> <span class="n">spaces</span>
</span><span class='line'>    <span class="n">tail</span> <span class="ow">&lt;-</span> <span class="n">char</span> <span class="sc">&#39;.&#39;</span> <span class="o">&gt;&gt;</span> <span class="n">spaces</span> <span class="o">&gt;&gt;</span> <span class="n">parseExpr</span>
</span><span class='line'>    <span class="n">return</span> <span class="o">$</span> <span class="kt">DottedList</span> <span class="n">head</span> <span class="n">tail</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意我们是如何使用 <code>&gt;&gt;</code> 将一系列的解析器动作串行起来然后在 do-块的右侧使用这一序列的。表达式 <code>char '.' &gt;&gt; spaces</code> 返回一个 <code>Parser ()</code> 类型的值，然后它与 <code>parseExpr</code> 组合了起来从而得到 <code>Parser LispVal</code> 值，这正是 do-块所期望的类型。</p>

<p>接着，我们再增加 Scheme 的单引号语法糖的支持：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">parseQuoted</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">parseQuoted</span> <span class="ow">=</span> <span class="kr">do</span>
</span><span class='line'>   <span class="n">char</span> <span class="sc">&#39;</span><span class="se">\&#39;</span><span class="sc">&#39;</span>
</span><span class='line'>   <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">parseExpr</span>
</span><span class='line'>   <span class="n">return</span> <span class="o">$</span> <span class="kt">List</span> <span class="p">[</span><span class="kt">Atom</span> <span class="s">&quot;quote&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码中大部分都是我们熟悉的东西：它读取一个单引号字符，再读取一个表达式并将其绑定到 <code>x</code>，然后返回 <code>(quote x)</code>，这是 Scheme 的概念。<code>Atom</code> 构造子就像普通的函数那样：传递给它一个字符串，它便返回一个 LispVal 值。对于 LispVal 值你可以像处理其他常见的值那样做什么都可以，例如将其置于一个列表中。</p>

<p>最后，我们要修改一下 <code>parseExpr</code> 使之包含新的解析器：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">parseExpr</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">parseExpr</span> <span class="ow">=</span> <span class="n">parseAtom</span>
</span><span class='line'>        <span class="o">&lt;|&gt;</span> <span class="n">parseString</span>
</span><span class='line'>        <span class="o">&lt;|&gt;</span> <span class="n">parseNumber</span>
</span><span class='line'>        <span class="o">&lt;|&gt;</span> <span class="n">parseQuoted</span>
</span><span class='line'>        <span class="o">&lt;|&gt;</span> <span class="kr">do</span> <span class="n">char</span> <span class="sc">&#39;(&#39;</span>
</span><span class='line'>               <span class="n">x</span> <span class="ow">&lt;-</span> <span class="n">try</span> <span class="n">parseList</span> <span class="o">&lt;|&gt;</span> <span class="n">parseDottedList</span>
</span><span class='line'>               <span class="n">char</span> <span class="sc">&#39;)&#39;</span>
</span><span class='line'>               <span class="n">return</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>这份代码演示了 Parsec 的最后一个特性：回溯。<code>parseList</code> 与 <code>parseDottedList</code> 能够识别出相同的字符串直至 <code>.</code> 符号；这就打破了候选需求不会在失败前消耗输入这个要求。<a href="http://www.cs.uu.nl/%7Edaan/download/parsec/parsec.html#try"><code>try</code></a> 组合子能够尝试运行指定的解析器，如果失败的话，它会回退到之前的状态。这样的话在尝试一个分支时时不会影响到另外待尝试的分支。</p>

<p>编译并运行目前的代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ghc -package parsec -o simple_parser listing3.4.hs
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="s2">&quot;(a test)&quot;</span>
</span><span class='line'>Found value
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="s2">&quot;(a (nested) test)&quot;</span>
</span><span class='line'>Found value
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="s2">&quot;(a (dotted . list) test)&quot;</span>
</span><span class='line'>Found value
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="s2">&quot;(a &#39;(quoted (dotted . list)) test)&quot;</span>
</span><span class='line'>Found value
</span><span class='line'><span class="nv">$ </span>./simple_parser <span class="s2">&quot;(a &#39;(imbalanced parens)&quot;</span>
</span><span class='line'>No match: <span class="s2">&quot;lisp&quot;</span> <span class="o">(</span>line 1, column 24<span class="o">)</span>:
</span><span class='line'>unexpected end of input
</span><span class='line'>expecting space or <span class="s2">&quot;)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，通过在我们的解析器中对 <code>parseExpr</code> 的引用，我们可以任意深度的嵌套它们。因而我们只需要使用很少的定义便可得到完备的 Lisp 阅读器，这就是递归的力量。</p>

<h3>练习</h3>

<ol>
<li>添加<a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-7.html#%_sec_4.2.6">反引号</a>语法糖的支持：Scheme 标准描述了它应该被展开为什么（quasiquote/unquote）</li>
<li>添加<a href="http://www.schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-9.html#%_sec_6.3.6">向量</a>的支持。Haskell 对此有点技穷了：GHC 提供了<a href="http://www.haskell.org/ghc/docs/latest/html/libraries/array-0.3.0.0/Data-Array.html">数组</a>类型，但是很难使用。严格的说，向量应该需要常量时间的索引与更新，但是破坏性的更新在纯函数式语言中是难以实现的。对于这个问题的解决，你可能在读完本指南后文的集合那一节之后会有更好的主意。</li>
<li>不使用 <code>try</code> 组合子，只使用解析器自身来完成同样的任务。你应当写一个可以匹配一个表达式串列的解析器，再写一个能匹配空值或一个点（Dot）与单个表达式所构成的表达式。将这两个解析器的返回值组合起来使之成为列表或加点列表，这个留给读者作为练习：你可能需要另行构造一个辅助函数。</li>
</ol>


<h2>三、 求值（1）</h2>

<h3>起步</h3>

<p>现在我们已经能够打印出我们是否能够识别出给定的程序片段。下面我们就向一个可用的 Scheme 解释器迈出第一步：为程序片段赋值。我们将从非常基本的东西开始，但是不一会你就可以发展到处理实际的计算。</p>

<p>我们这样开始：告诉 Haskell 如何打印各种可能的 <code>LispVal</code> 值的字符串表示：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">showVal</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</span><span class='line'><span class="nf">showVal</span> <span class="p">(</span><span class="kt">String</span> <span class="n">contents</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span> <span class="o">++</span> <span class="n">contents</span> <span class="o">++</span> <span class="s">&quot;</span><span class="se">\&quot;</span><span class="s">&quot;</span>
</span><span class='line'><span class="nf">showVal</span> <span class="p">(</span><span class="kt">Atom</span> <span class="n">name</span><span class="p">)</span> <span class="ow">=</span> <span class="n">name</span>
</span><span class='line'><span class="nf">showVal</span> <span class="p">(</span><span class="kt">Number</span> <span class="n">contents</span><span class="p">)</span> <span class="ow">=</span> <span class="n">show</span> <span class="n">contents</span>
</span><span class='line'><span class="nf">showVal</span> <span class="p">(</span><span class="kt">Bool</span> <span class="kt">True</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;#t&quot;</span>
</span><span class='line'><span class="nf">showVal</span> <span class="p">(</span><span class="kt">Bool</span> <span class="kt">False</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;#f&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是我们第一次对模式匹配进行郑重介绍。模式匹配是代数数据类型的一种解构方式，即基于代数数据类型的构造子遴选代码从句，然后将成员绑定到变量。任何构造子都可以出现在模式中；如果一个模式的标签与值的标签相同，并且所有的子模式也都与相应的成员匹配，那么这个模式便匹配到一个值。模式匹配可以任意深度的嵌套，匹配处理是由内而外、由左向右的次序进行的。函数定义中的从句会以字面的次序，逐个进行模式匹配。如果这让你糊涂，下面在深入探索求值器的时候，你会看到一些深层嵌套的模式示例。</p>

<p>现在，你只需要知道上述函数定义中每个从句都会匹配 <code>LispVal</code> 的一个构造子，右侧则描述了如何处理构造子的值。</p>

<p><code>List</code> 与 <code>DottedList</code> 相似，但是我们需要定义一个辅助函数 <code>unwordsList</code> 将列表所包含的列表转化为字符串。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">showVal</span> <span class="p">(</span><span class="kt">List</span> <span class="n">contents</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;(&quot;</span> <span class="o">++</span> <span class="n">unwordsList</span> <span class="n">contents</span> <span class="o">++</span> <span class="s">&quot;)&quot;</span>
</span><span class='line'><span class="nf">showVal</span> <span class="p">(</span><span class="kt">DottedList</span> <span class="n">head</span> <span class="n">tail</span><span class="p">)</span> <span class="ow">=</span> <span class="s">&quot;(&quot;</span> <span class="o">++</span> <span class="n">unwordsList</span> <span class="n">head</span> <span class="o">++</span> <span class="s">&quot; . &quot;</span> <span class="o">++</span> <span class="n">showVal</span> <span class="n">tail</span> <span class="o">++</span> <span class="s">&quot;)&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>unwordsList</code> 行为上像 Haskell 标准库中的 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$vunwords"><code>unwords</code></a> 函数，将一列单词以空格间隔连在一起。因为我们所处理的是一列 <code>LispVal</code> 值而不是单词，因此我们定义了这个函数。它首先将 <code>LispVal</code> 值转化为字符串表示然后再对它们应用 <code>unwords</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">unwordsList</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">String</span>
</span><span class='line'><span class="nf">unwordsList</span> <span class="ow">=</span> <span class="n">unwords</span> <span class="o">.</span> <span class="n">map</span> <span class="n">showVal</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>unwordsList</code> 的定义不包含任何参数。这是“点自由（point-free）”风格的一个例子：纯粹以函数的部分应用与函数组合的方式来定义函数，不考虑具体的值（点）。这里我们使用了两个内建的函数的组合来定义 <code>unwordsList</code>。首先，我们对 <code>ShowVal</code> 部分应用了 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$vmap"><code>map</code></a> 函数，这样便可创建一个函数，它可以接受一个 <code>LispVal</code> 值列表并各个值的字符串表示所构成的列表。Haskell 函数都是丘奇化（Curried）了的：这意味着一个接受两个参数值的函数，例如 <code>map</code>，实际上是一个返回“接受一个参数值的函数”的函数。这个新函数可以与其他函数组合，留待后续应用。在本例中，我们是将 <code>map showVal</code> 这一部分应用所得到的函数与 <code>unwords</code> 复合，前者用于生成一个字符串列表，后者则使用空格作为间隔将列表元素合并起来。</p>

<p>上面我们使用了 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#tShow"><code>show</code></a> 函数。这个是 Haskell 标准库中的函数，它可以帮助你将任何类型的值转化为字符串，前提是这种类型必须是 <code>Show</code> 类的实例。我们希望 <code>LispVal</code> 具备这一能力，因此就需要将它变为 <code>Show</code> 类的一员，即定义它的 <code>show</code> 方法为 <code>showVal</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">instance</span> <span class="kt">Show</span> <span class="kt">LispVal</span> <span class="kr">where</span> <span class="n">show</span> <span class="ow">=</span> <span class="n">showVal</span>
</span></code></pre></td></tr></table></div></figure>


<p>有关类型类完整的介绍超出了本指南的范畴；你可以在<a href="http://www.haskell.org/tutorial/classes.html">其他指南</a>与 <a href="http://www.haskell.org/onlinereport/decls.html#sect4.3">Haskell 98 标准</a>中获得更多的信息。</p>

<p>现在，我们尝试修改 <code>readExpr</code> 函数，让它返回所解析的值的字符串表示，而不是那个“Found value”：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">readExpr</span> <span class="n">input</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">parse</span> <span class="n">parseExpr</span> <span class="s">&quot;lisp&quot;</span> <span class="n">input</span> <span class="kr">of</span>
</span><span class='line'>    <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="s">&quot;No match: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">err</span>
</span><span class='line'>    <span class="kt">Right</span> <span class="n">val</span> <span class="ow">-&gt;</span> <span class="s">&quot;Found &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">val</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后编译并运行：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ghc -package parsec -o parser listing4.1.hs
</span><span class='line'><span class="nv">$ </span>./parser <span class="s2">&quot;(1 2 2)&quot;</span>
</span><span class='line'>Found <span class="o">(</span>1 2 2<span class="o">)</span>
</span><span class='line'><span class="nv">$ </span>./parser <span class="s2">&quot;&#39;(1 3 (\&quot;this\&quot; \&quot;one\&quot;))&quot;</span>
</span><span class='line'>Found <span class="o">(</span>quote <span class="o">(</span>1 3 <span class="o">(</span><span class="s2">&quot;this&quot;</span> <span class="s2">&quot;one&quot;</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>


<h3>开始写求值器：初级</h3>

<p>现在开始写一个求值器。求值器的作用是将“代码”数据类型映射为“数据”数据类型，即求值结果。在 Lisp 语言中，数据类型对于“代码”与“数据”而言都是相同的，因此我们的求值器将会返回一个 <code>LispVal</code> 值。其他语言通常会有各种语法形式的更为复杂的代码结构。</p>

<p>对数字、字符串和带引号的列表进行求值相当的简单：返回数据本身。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">eval</span> <span class="ow">::</span> <span class="kt">LispVal</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">eval</span> <span class="n">val</span><span class="o">@</span><span class="p">(</span><span class="kt">String</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">val</span>
</span><span class='line'><span class="nf">eval</span> <span class="n">val</span><span class="o">@</span><span class="p">(</span><span class="kt">Number</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">val</span>
</span><span class='line'><span class="nf">eval</span> <span class="n">val</span><span class="o">@</span><span class="p">(</span><span class="kt">Bool</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">val</span>
</span><span class='line'><span class="nf">eval</span> <span class="p">(</span><span class="kt">List</span> <span class="p">[</span><span class="kt">Atom</span> <span class="s">&quot;quote&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">])</span> <span class="ow">=</span> <span class="n">val</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里引入了新的模式形式。<code>val@(String _)</code> 匹配包含字符串的 <code>LispVal</code> 值，然后将整个 <code>LispVal</code> 绑定到 <code>val</code>，而不理睬 <code>String</code> 构造子的内容。这样所得的结果其类型为 <code>LispVal</code>，而不是字符串类型。下划线符号表示“不要结果，只要过程”的变量，它可以匹配任何值但是不进行绑定。下划线符号可用于任何模式中，但是它与 <code>@-模式</code> 结合起来的时候最有用，另外就是在构造子测试中可以使用它来忽略那些不关心的成员。</p>

<p>上面代码中最后那行就是我们前面提到的嵌套模式。<code>List</code> 所包含的数据类型是 <code>[LispVal]</code>，即 <code>LispVal</code> 值的列表，我们使用只有两个元素的列表来匹配它。这个只具有两个元素的列表，第一个元素是 &#8220;quote&#8221; 符号，第二个元素可以是任何东西并且也是我们要得到的结果。</p>

<p>我们可以将 <code>eval</code> 集成到现有代码中。首先需要将 <code>readExpr</code> 改回来，使之返回表达式而非表达式的字符串表示：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">readExpr</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">readExpr</span> <span class="n">input</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">parse</span> <span class="n">parseExpr</span> <span class="s">&quot;lisp&quot;</span> <span class="n">input</span> <span class="kr">of</span>
</span><span class='line'>    <span class="kt">Left</span> <span class="n">err</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="o">$</span> <span class="s">&quot;No match: &quot;</span> <span class="o">++</span> <span class="n">show</span> <span class="n">err</span>
</span><span class='line'>    <span class="kt">Right</span> <span class="n">val</span> <span class="ow">-&gt;</span> <span class="n">val</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后修改 <code>main</code> 函数，让它可以读取表达式，求值，转化为字符串并显示。我们已经知道 <code>&gt;&gt;=</code> 单子序列操作符和函数复合符是怎么回事了，现在可以让它们拥有用武之地：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
</span><span class='line'><span class="nf">main</span> <span class="ow">=</span> <span class="n">getArgs</span> <span class="o">&gt;&gt;=</span> <span class="n">print</span> <span class="o">.</span> <span class="n">eval</span> <span class="o">.</span> <span class="n">readExpr</span> <span class="o">.</span> <span class="n">head</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里，我们取得 <code>getArgs</code> 动作的结果，然后将其传递至下面四个函数的组合：</p>

<ol>
<li>取得第一个值（head）</li>
<li>解析这个值（readExpr）</li>
<li>对解析结果求值（eval)</li>
<li>将所求的值转化为字符串表示并显示（print）</li>
</ol>


<p>以常规的方式编译并运行现在的代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>ghc -package parsec -o <span class="nb">eval </span>listing4.2.hs
</span><span class='line'><span class="nv">$ </span>./eval <span class="s2">&quot;&#39;atom&quot;</span>
</span><span class='line'>atom
</span><span class='line'><span class="nv">$ </span>./eval 2
</span><span class='line'>2
</span><span class='line'><span class="nv">$ </span>./eval <span class="s2">&quot;\&quot;a string\&quot;&quot;</span>
</span><span class='line'><span class="s2">&quot;a string&quot;</span>
</span><span class='line'><span class="nv">$ </span>./eval <span class="s2">&quot;(+ 2 2)&quot;</span>
</span><span class='line'>
</span><span class='line'>Fail: listing6.hs:83: Non-exhaustive patterns in <span class="k">function </span><span class="nb">eval</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在这个程序还不能做多么有用的事（连 <code>(+ 2 2)</code> 都不支持），但是基本的骨架已经建好了。下面我们要为其添加更多的函数，使它更有用。</p>

<h3>增加基本的原语</h3>

<p>下面，要改进我们的 Scheme 解释器，让它成为一个简单的计算器。虽然它依然无法成为“编程语言”，但是距离目标更近了一步。</p>

<p>我们从增加 <code>eval</code> 的一个子句使之支持函数应用的处理开始。记住，一个函数定义的所有子句必须放在一起，并且它们会被按照代码中的次序求值，因此在前面已经出现的 <code>eval</code> 子句之后添加：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">eval</span> <span class="p">(</span><span class="kt">List</span> <span class="p">(</span><span class="kt">Atom</span> <span class="n">func</span> <span class="kt">:</span> <span class="n">args</span><span class="p">))</span> <span class="ow">=</span> <span class="n">apply</span> <span class="n">func</span> <span class="o">$</span> <span class="n">map</span> <span class="n">eval</span> <span class="n">args</span>
</span></code></pre></td></tr></table></div></figure>


<p>这又是一个嵌套模式的示例，但是这次我们是根据 cons 操作符“:”进行匹配，而不是一个字面上的列表。在 Haskell 中，列表实际上只是一个语法糖，它包藏了 cons 操作符的应用链以及空列表：<code>[1, 2, 3, 4] = 1:(2:(3:(4:[])))</code>。通过这种根据 cons 自身而不是字面列表的模式匹配，我们可以宣称“请给我列表剩余的部分”，而不是“请给我列表的第二个元素”。例如，如果我们将 <code>(+ 2 2)</code> 传递给 <code>eval</code>，那么 <code>func</code> 便会被绑定到 <code>+</code>，<code>args</code> 则会被绑定到 <code>[Number 2, NUmber 2]</code>。</p>

<p>上面的 <code>eval</code> 子句剩下的部分由两个函数构成，其中有一个还未被定义。我们必须要递归的对每个参数值进行求值，因此我们将 <code>eval</code> 映射至 <code>args</code> 所包含的每个值。这样做可以让我们很方便的写出诸如 <code>(+ 2 (- 3 1) (* 5 4))</code> 这样的表达式。然后我们获取参数值求值后所得结果的列表，将它与起初的函数 <code>func</code> 传递于 <code>apply</code>：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">apply</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span>
</span><span class='line'><span class="nf">apply</span> <span class="n">func</span> <span class="n">args</span> <span class="ow">=</span> <span class="n">maybe</span> <span class="p">(</span><span class="kt">Bool</span> <span class="kt">False</span><span class="p">)</span> <span class="p">(</span><span class="o">$</span> <span class="n">args</span><span class="p">)</span> <span class="o">$</span> <span class="n">lookup</span> <span class="n">func</span> <span class="n">primitives</span>
</span></code></pre></td></tr></table></div></figure>


<p>内建函数 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$vlookup"><code>lookup</code></a> 可在一个二元组构成的列表中查询一个键对应的值。不过，在列表所包含的二元组中如果未包含所查询的键，<code>lookup</code> 便会失败。为了表示这一现象，<code>lookup</code> 会返回内建类型 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$tMaybe"><code>Maybe</code></a> 的实例。我们使用函数 <a href="http://www.haskell.org/onlinereport/standard-prelude.html#$vmaybe"><code>maybe</code></a> 对 <code>lookup</code> 成功或失败的情况分别进行处理。如果 <code>lookup</code> 一无所获，那么便返回一个 <code>Bool False</code> 值，即 <code>#f</code>（后文我们会使用更为稳健的错误处理机制）。如果 <code>lookup</code> 获得了键对应的值（它是一个函数），我们便使用 <code>($ args)</code> 将其应用于参数值。</p>

<p>下面，定义我们支持的原语列表：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">primitives</span> <span class="ow">::</span> <span class="p">[(</span><span class="kt">String</span><span class="p">,</span> <span class="p">[</span><span class="kt">LispVal</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">LispVal</span><span class="p">)]</span>
</span><span class='line'><span class="nf">primitives</span> <span class="ow">=</span> <span class="p">[(</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">numericBinop</span> <span class="p">(</span><span class="o">+</span><span class="p">)),</span>
</span><span class='line'>              <span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">,</span> <span class="n">numericBinop</span> <span class="p">(</span><span class="o">-</span><span class="p">)),</span>
</span><span class='line'>              <span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">,</span> <span class="n">numericBinop</span> <span class="p">(</span><span class="o">*</span><span class="p">)),</span>
</span><span class='line'>              <span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">,</span> <span class="n">numericBinop</span> <span class="n">div</span><span class="p">),</span>
</span><span class='line'>              <span class="p">(</span><span class="s">&quot;mod&quot;</span><span class="p">,</span> <span class="n">numericBinop</span> <span class="n">mod</span><span class="p">),</span>
</span><span class='line'>              <span class="p">(</span><span class="s">&quot;quotient&quot;</span><span class="p">,</span> <span class="n">numericBinop</span> <span class="n">quot</span><span class="p">),</span>
</span><span class='line'>              <span class="p">(</span><span class="s">&quot;remainder&quot;</span><span class="p">,</span> <span class="n">numericBinop</span> <span class="n">rem</span><span class="p">)]</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单子求索]]></title>
    <link href="http://ghacker.github.com/blog/2012/04/13/monads-for-the-curious-porgrammer/"/>
    <updated>2012-04-13T09:36:00+08:00</updated>
    <id>http://ghacker.github.com/blog/2012/04/13/monads-for-the-curious-porgrammer</id>
    <content type="html"><![CDATA[<p>原文见 <a href="http://bartoszmilewski.com">Bartosz Milewski 的系列博文</a>。</p>

<pre><code>如是我闻：

单子空空，力量无限
用之愈多，所得愈多
谈之愈多，知之愈少

           ——《单子之道》
</code></pre>

<p>这样说不知是否夸张，似乎每个懂得了单子的程序员都会写一篇关于它的文章（而且每一篇的开头都是：网络上已经有了许多单子指南，但是……）。原因是对于单子的理解像是一种灵魂感悟，你想与他人分享。</p>

<p>人们对单子的认知如同盲人摸象。你会看到有的人将它描述为容器，有的人将它描述为动作。有的人认为它是用于封装副作用的，也有人将其视为范畴论中自函子的实例。</p>

<p>很难说清楚单子是个什么东西，因为它与我们日常生活中的事物毫无关系。对于面向对象编程中的对象，即使婴儿都知道对象是什么（可以放进嘴里的东西），单子该如何具化？</p>

<!--more-->


<h2>第一部分</h2>

<p>还是让我们首先回答一个相关的问题：</p>

<h3>单子为何这么二？</h3>

<p>单子使得纯函数式程序员能够实现变量、状态、I/O 以及其他那些并非函数的东西。嗯，那你可能要说了，他们活该啊……他们将手绑在身后，吹牛说他们可以用脚趾头打字。就让他们作吧，我们没必要关心。</p>

<p>事实上，我们在命令式语言中经常使用的那些非函数式的东西是诸恶之源。以副作用为例，聪明的程序员（可理解为手指多次被烧的家伙）出于对副作用的畏惧而倾力消减全局变量与静态变量的使用。如果你知道你在干什么，这样是切实可行的。但是游戏规则的真正篡改者是多线程。线程共享状态的控制已经逾越了优秀的编程经验的界限，成为了一项必备的生存技能。一些极端的编程模型已经完全的消除了共享机制，像 Erlang 那样完全的进程隔离，并将消息传递限制为值传递。</p>

<p>单子在完全无政府主义的命令式语言与孤立主义的类 Erlang 语言之间的地带扎根。单子不禁止共享或副作用，而是让你去控制它们。并且由于这种控制是通过类型系统来运作的，因此使用单子的程序可由编译器来检测其正确性。想想命令式程序中数据竞争测试的难度，我认为花点时间学习一下单子是值得的。</p>

<p>也有一个完全不同的概念：元编程。C++ 元编程中所用的模板语言是一种纯函数式语言（见我的博文，<a href="http://bartoszmilewski.wordpress.com/2009/10/21/what-does-haskell-have-to-do-with-c/">Haskell 与 C++ 的关系</a>）。如果单子在函数式编程中非常重要，那么在 C++ 元编程中也必会如此。事实的确如此。我打算在以后的文章中来讨论这个问题。</p>

<p>现在，我们开始探索单子究竟是个什么东西。</p>

<h3>范畴论中的答案</h3>

<p>如果你不知道范畴论，也不必担心。它其实是相当简单的概念，可以描述许多事物，而且你还能从中赚取一些吹牛的资本。我的主要目标是分享一些数学上的直觉。这部分内容，我会解释范畴、函子、自函子，以它们为基础进而解释单子。我会给出来自日常生活与编程中的一些的实例。我会在下一部分真正的讲述单子及其实际应用，因此请耐心一些。</p>

<h4>范畴</h4>

<p>范畴是集合与函数概念的自然扩展。泛化了的集合在范畴中被称为对象（一个稍微有些实际语意相当中性的词语），泛化了的函数被称为态射。实际上，范畴的标准实例是一个集合与函数构成的范畴，称为集合范畴。</p>

<p>一个态射（可理解为“函数”）从一个对象（可理解为“集合”）到另一个对象。数学函数，例如 sin 或 exp，通常是从一个实数集到另一个实数集的。但是你也可以定义 isPrime 这样的函数，从自然数集到布尔数集，或者定义一个 price 函数，从货物集到数集。</p>

<p>对于态射，只需知道它们可被复合即可。对于从 A 到 B 的一个态射，A->B，还有一个从 B 到 C 的态射，B->C，那么它们可复合维一个从 A 到 C 的态射，A->C。就像函数的标准复合那样，态射复合也必须满足结合律，这样在复合多于两个态射时，我们就可以省去一些括号了。</p>

<p>实际上，我们还需要知道一件事。对于每个对象，有一种特定的态射称为 identity（单位态射），它什么也不做，当它与其他态射复合时会产生与后者相同的态射。</p>

<blockquote><p>说点题外话，范畴不一定非要建立于集合与函数之上。通过圆圈与箭头就可以很容易构建出简单的范畴。图 1 显示了一个包含两个对象（圆圈）与四个态射（箭头），可以看出任意两个态射都可以复合，而且 i<sub>A</sub> 与 i<sub>B</sub> 是单位态射。</p>

<p><div style="width:100%;text-align:center;"><img src="http://ghacker.github.com/images/posts/monad-for-curious-programmer-01.gif" title="两个对象与四个态射构成的简单范畴" alt="图 1. 两个对象与四个态射构成的简单范畴" /></div></p></blockquote>

<p>就这么多了。希望我已经使你深信范畴并不是什么了不起的东西。但是，我们还是务实一些。在编程语言中一个真正重要的范畴就是类型与函数的范畴，在 Haskell 中它被称为 Hask 范畴。一般是有一个基本类型的有限集，例如整型、布尔类型等；还有一个派生类型的无限集，像整型列表，从整型到布尔类型的函数等。在 Hask 中，类型仅仅是值的集合。例如 Char 类型是 {&#8216;a&#8217;, &#8216;b&#8217;, &#8216;c&#8217;, &#8230;} 集合。</p>

<p>因此，在 Hask 范畴中，类型是对象，函数是态射。实际上，函数将一种类型映射为另一种类型（暂时忘掉多个参数的函数——它们可以被丘奇化构建为单参数函数——和多态函数——它们是函数族）。并且在函数式编程观念中，这些函数如果给它们同样的值，它们也会返回同样的结果——没有副作用。</p>

<p>函数复合不过是将一个函数作为另一个函数的参数而已。单位函数接受 x 然后立刻将其返回。</p>

<p>这些都还好理解，但是有什么用呢？也许你会问。那么我们就来进行第一次洞察和顿悟吧。如果有一种你称之为编程本质的东西，它就是可复合性。在任何编程风格中，你总是会将一些小块复合起来构建你的程序，这些小块又来自更小的块的复合。这就是具有可复合态射的范畴之所以如此重要的原因。乐高积木的本质就在于它们的适配性、可组合性，而非颜色与尺寸。函数式编程的本质就是函数如何协同工作：如何通过小的函数来构建大的函数。</p>

<p>每个范畴都是由它所选择的对象和态射来定义的。但是否有一种方法可以描述某个给定的范畴，并且这种描述独立于范畴所选的特定的对象与态射？即如何展现一个特定范畴的内部结构？数学家们肯定知道怎么做。你需要将范畴映射为其他范畴，同时保留对象之间的态射以及态射的复合方式。这样的映射可以让你发现范畴之间的相似性并对不同种类的范畴进行编排。至此，事情才真正变得有趣起来。</p>

<h4>函子</h4>

<p>函子 F 是一个范畴到另一个范畴的映射：它将对象映射为对象，将态射映射为态射。但是函子不能随意胡为，因为这样会破坏我们所追求的结构。因此我们必须要施加一些明确的（数学家喜欢这个词）约束。</p>

<p>首先，如果你在第一个范畴中两个对象之间有一个态射，它被很好的映射为第二个范畴中两个对象的之间的态射。如图 2 所示，对象 A 被映射为 F(A)，对象 B 被映射为 F(B)。从 A 到 B 的态射 f 被映射为从 F(A) 到 F(B) 的态射 F(f)。数学家说像这样的图必须满足交换律，就是说无论是先将 A 映射为 F(A) 然后应用 F(f)，还是先应用 f 然后将 B 映射为 F(B)，结果必须相同。</p>

<p style="text-align:center;"><img src="http://ghacker.github.com/images/posts/monad-for-curious-programmer-02.gif" title="函子" alt="图 2. 作用于对象 A 与 B 及态射 f 的函子 F。底部是 F 的域（源）范畴，上部是它的陪域（目标）范畴"></p>


<p>还有，这样的映射应当保留态射的复合性。因此如果态射 h 是 f 与 g 的复合，那么 F(h) 必定是 F(f) 与 F(g) 的复合。当然，函子也必须将单位态射映射为单位态射。</p>

<p>为了感知函子是如何被这些条件约束的，想象一下如何将图 1 中的范畴映射为其自身（像这样的函子只是重新安排了一个范畴内部的东西）。有两种简单的映射可将两个对象折叠为一个（要么是 A，要么是 B），并将所有态射转化为单位态射。还有一种单位函子，可将两个对象映射为其自身，也可将所有态射映射为其自身。最后，还有一种有趣的函子，它可将 A 映射为 B，将 B 映射为 A，将 f 与 g 的功能对换。现在想像一下有一种与图 1 相似的范畴，只是去掉了态射 g（是的，这仍然是一个范畴）。这一下图 1 所示的范畴与这个新范畴之间除了折叠函子之外，其他函子都不存在了。这是因为这两个范畴有着完全不同的结构。</p>

<p>现在我们进入更加熟悉的领域。因为我们主要是对 Hask 这种范畴感兴趣，那么我们就定义一个函子，将这个范畴映射为其自身（像这样的函子称为自函子）。Hask 中的一个对象就是一个类型，因此我们的函子必须将类型映射为类型。这种方式看上去就像是 Hask 中的函子可以从一种类型构建出另一种类型——它就是一个类型构造子。不要被名字搞晕了：类型构造子在你的程序中创建新类型，但是那种类型是已经存在于 Hask 范畴之中。</p>

<p>以列表类型构造子为例。对于给定的任何类型，列表构造子都可以构建出这种类型的列表。整型类型 Integer 被映射为整型列表，用 Haskell 的行话来说，就是 [Integer]。注意这并非是定义在整型数值，例如 1, 2 或 3 之上的映射。它也不会在 Hask 范畴中增加一种新的类型——[Integer] 已经存在于 Hask 范畴之中。它只是将一种类型映射为另一种类型而已。对于 C++ 程序员而言：可以思考一下类型 T 与 T 的容器之间的映射，例如 std::vector<T>。</p>

<p>类型的映射比较容易，对于函数该当如何？我们必须寻找一种方式，可以接受一个特定的函数并将其映射为一个操作列表的函数。这也很容易：将这个函数依次作用于列表中每个元素即可。Haskell 中有一种（高层）函数可以做到这一点。这种函数被称为 map，它接受一个函数和一个列表，然后返回一个新的列表（或者由于丘奇化，你可以说它接受了一个函数并返回一个可以操作列表的函数）。在 C++ 中，有一种类似的模板函数，std::transform（嗯，它接受两个迭代器和一个函数对象，不过思想是相同的）。</p>

<p>数学家通常使用图形来表示态射与函子的性质（如图 2）.用于表示态射的箭头通常是水平的，用于表示函子的箭头通常是竖直的（向上的）。这就是为什么函子对态射的映射通常被称为提升。你可以接受一个操作整型数的函数，然后将其提升为一个操作整型列表的函数，等等。</p>

<p>列表函子显然保持了函数的复合性与单位性（这个要留给读者当作一个简单但有意义的课后作业）。</p>

<p>现在来进行第二次顿悟。编程的第二个本质是什么？复用性！来看我们是如何做到的：我们接受已经实现的所有函数，然后将其提升为列表级别的函数。我们得到列表操作函数基本上是免费的（好吧，我们得到的是那些函数的一个很小但是非常重要的子集）。同样的技巧可用于所有类型的容器，数组、树、队列、智能指针等等。</p>

<p>这一切都非常优美，而且你不需要懂范畴论就可以应用这些函数处理列表。在编程中能够发现模式总是好事情，而这个则是模式的管理者。真正的革命始于单子。猜猜原因是什么？列表函子实际上是单子。单子相对于函子，只不过配料更多而已。</p>

<blockquote><p>这种通过映射来暴露系统结构的描述背后的直觉是什么？思考如图 3 所示的伦敦地铁路线图。该图只是由许多圆圈与线段构成。但它们是有意义的，因为伦敦城与这副图之间存在着映射。圆圈与地铁站相关，线段与铁路线相关。更为重要的是，如果列车在两个站点之间运行，那么图中相应的圆圈可以用线段连接起来，反之亦然：这些就是映射所保持的约束。地铁路线图显示了一种存在于伦敦（地下）的一种特定的结构，通过映射的方式使之昭然若揭。</p>

<p><div style="width:100%;text-align:center;"><img src="http://ghacker.github.com/images/posts/monad-for-curious-programmer-03.gif" title="伦敦地铁路线图" alt="图 3. 伦敦地铁路线图" /></div></p>

<p>有趣的是，我在此所做的也是映射：伦敦与地铁路线图对应着两个范畴。地铁站/圆圈是对象，地铁线路/线段是态射。这个例子如何？</p></blockquote>

<h4>自函子</h4>

<p>数学家喜欢可以保持明确约束的映射。正如我所解释过的，这样的映射从实现的细节中抽象出内部结构。但是你也能够通过研究自我映射的方式对结构有更多的了解。将一个范畴映射为其自身的函子称为自函子（像是可让你看见内部事物的内窥镜）。如果说函子揭示了范畴之间的相似性，那么自函子就是揭示了范畴的自相似性。观察一下图 4 所示的分形蕨类，你就会明白自相似性多么强大。</p>

<p style="text-align:center;"><img src="http://ghacker.github.com/images/posts/monad-for-curious-programmer-04.png" title="自相似性" alt="图 4. 由 4 个自态射构造的分型蕨类"></p>


<p>稍微想像一下，你就会看到列表函子揭示了 Hask 范畴中像蕨类那样的结构，如图 5 所示。一组 Char 类型构成 Char 列表，一组 Char 列表又构成 Char 列表的列表，诸如此类，无穷无尽。由 Char 到 Bool 的函数所描述的水平结构被提升到高而更高的层次，使之作用于列表、列表的列表等等。</p>

<p style="text-align:center;"><img src="http://ghacker.github.com/images/posts/monad-for-curious-programmer-05.jpg" title="列表函子" alt="图 5. 列表类型构造子的行为揭示了 Hask 内部类似蕨类的结构。这个函子将各个函数提升了，函数作用于水平方向"></p>


<blockquote><p>可将接受类型参数的 C++ 模板视为类型构造子。用它来定义一个函子怎么样？（不严格的说——C++ 不像 Haskll 那样数学化）。你必须自问：类型参数是被以任意方式约束的么？通常会很难回答，因为类型约束是隐藏于具体模板中的，只有在初始化期间方可测试。例如，std::vector 的类型参数必须是可复制的。这样的话就排除了具有私有成员或者删除了 copy 构造函数的类。不过这没什么问题，因为可复制的类型形成了一个子范畴（相当不严格的说）。重要的是一个可复制的向量其本身是可复制的，因此态射的“自”的部分就有了。通常你会希望能够将类型构造子所创建的类型再喂给这个类型构造子，就像这样 std::vector&lt;std::vector<Foo>>。当然，你也必须能够以一种一般化的方式提升函数，就像 std::transform 那样。</p></blockquote>

<h4>单子</h4>

<pre><code>呃，单子。
    —— Haskell Simpson
</code></pre>

<p>终于到了揭开面纱的时刻了。我将会从单子的定义开始，其定义建立于前几节内容之上并且被数学家们广为使用。还有一个不那么直观但是更容易在编程中使用的定义，我会放在后面讲。</p>

<p>单子是一个自函子，伴随两种竖直方向特定的态射族，一种是向上的，一种是向下的（对于方向，参考图 5）。向上的那种态射被称为 unit，向下的那种被称为 join。</p>

<p>现在我们已经见识了太多的映射魔法，因此还是放慢脚步去构建一些直觉。记住，函子映射了对象：在我们的例子中，类型是值的集合。函子不会去看对象内部是什么，这个事情通常是态射做的。在我们的例子中，态射是将一种类型的值映射为另一种类型的值的函数。我们的函子是通过类型构造子定义的，通常是将一种穷类型映射为富类型，例如 Bool 类型是两个值的集合，而 [Bool] 是两个值所构成的无穷无尽的列表集合。</p>

<p>unit 态射接受一种穷类型的值，然后选一个富类型的值，然后宣称它们大致等价。Bool 对象的 True 值的一个大致等价是 [Bool] 对象的一个单元素列表 [True]。类似，unit 将 False 映射为 [False]。它也可以将 5 映射为 [5] 等等。</p>

<p>可将 unit 视为将一个底层的值嵌入到高层的一种自然的方式。顺便说一下，在编程中，那些为任意类型而定义的函数族被称为多态函数。在 C++ 中，我们可将 unit 表示为模板，像这样：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">unit</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'>    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">vec</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了更好的解释 join 态射，想象一下作用两次的函子。例如，对于一个给定的类型 T，列表函子会首先构造类型 [T]，然后构造 [[T]]。join 态射会通过子列表的合并而移除一层列表态。通俗的说，它只是将内部列表连接起来。例如，给定的 [[a, b], [c], [d, e]]，join 态射会将其映射为 [a, b, c, d , e]。它是从富类型到穷类型的多向到单向的映射。join 态射的类型参数化也会形成一个多态函数（C++ 中的模板）。</p>

<p>有几条单子定律定义了 unit 与 join 的性质（例如 unit 与 join 彼此对立），但是我不打算对它们详加解释。unit 与 join 存在的重要意义是对自函子施加了新的约束，从而将范畴更多的内部结构刻画出来。</p>

<p>对于以 unit 为中性元的所有乘法而言，数学家将 join 视为其祖父。它对于数学家非常重要，因为乘法导出了代数结构，并且事实上单子对于代数的构建并发现其隐含的性质具有重要作用。</p>

<p>与数学家不同，我们这些程序员对于代数结构不感兴趣。因此一定有什么东西使得单子如此重要。正如我在开始时所讲，在编程中我们经常面临那些没法自然转化为函数式范式的问题。有一些计算方式可以使用命令式语言很好的表示。这并不是说他们不能被转换为函数式，仅仅是这种转换有些笨拙和乏味而已。单子提供了一种优雅的工具来实现这种转换。单子使得在函数式编程中吸收与同化命令式编程风格成为可能，以致许多人宣称（戏谑？）Haskell 是最好的命令式语言。像所有的东西一样，函数式的单子势必峰回路转，在命令式编程中找到它的位置。</p>

<h2>第二部分</h2>

<h3>函数式编程面临的挑战</h3>

<p>函数是什么，你懂的：每次以相同的参数调用它，它总是会返回同样的结果。大量有用的计算直接映射为函数，但依然有许多计算没法这样做。我们经常不得不涉及一些非函数的计算方法。在非函数式语言中，这样的计算也经常被称为“函数”。Eugenio Moggi，这哥们将单子引入了计算，对于这样的“函数”给出了一些例子：</p>

<ul>
<li>偏“函数”：永不截止的参数值（例如陷入了死循环）。这些并非数学意义上的函数。</li>
<li>非确定“函数”：它们不返回单个结果，而是返回多个可选的结果。非确定解析器类似这样。对于给定的输入，它们返回一个可能的解析结果的集合，这些解析结果都可能是正确的，具体选择需要依赖具体环境。这样的函数并非真正的函数，因为一个函数必须要返回单个值。</li>
<li>带副作用的“函数”：它们能够访问和修改外部状态，并且可被重复调用，每次都依赖于状态而返回不同的结果。</li>
<li>抛出异常的“函数”：它们并非是为特定的参数值（或状态）而定义，并且它们抛出异常而不是返回一个结果。</li>
<li>延续体（Continuation）。</li>
<li>交互输入：getchar 是个很好的例子。它的结果依赖于键盘的敲击。</li>
<li>交互输出：putchar 是个很好的例子。因为它不能返回任何东西（如果它返回一个错误码，它就不依赖于参数值），所以它不是函数。还有，如果我们想将任何东西显示于屏幕上的时候，它便不能被优化掉。</li>
</ul>


<p>奇异的事情是使用一些创造性的方法，这些问题是可以使用纯函数的方法来解决的。我不会讨论所有的问题，但是我会向你展示一系列渐进而有趣的例子。</p>

<h3>错误传播与异常</h3>

<p>所有人都要处理错误的传播。我们将问题剖开：你正在定义一种仅针对可能参数值的子集而返回有效结果的计算。如果参数值是“错误”的，那么这个函数会发生什么？嗯，你会让他返回一个错误。</p>

<p>最简单的情况下，你可能会向返回值增加一位，表示成功或者失败。有时你也可以在返回值类型中增加一位：如果结果正确，那么它就是非负的，否则就是错误的。或者，如果返回值是指针，你可以返回一个空指针。但是这些办法只是为了效率而引入的一些小技巧。与大部分的小技巧一样，它们可能会导致危险的代码。看下面的代码（不大正确）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">size_t</span> <span class="n">off</span> <span class="o">=</span> <span class="n">fileName</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">);</span>
</span><span class='line'><span class="n">string</span> <span class="n">ext</span> <span class="o">=</span> <span class="n">fileName</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">off</span><span class="p">,</span> <span class="n">fileName</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">off</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果 fileName 不包含点，结果是一个特定的值 npos，表示一个错误。问题是 npos 与非错误的结果并非同一类型，以致它在安静的传递给 string::substr 函数时导致一个未定义的行为。</p>

<p>一个更加通用并且安全的方案是更改——扩展——结果的类型，使之包含一个错误位。对于任何类型你都可以这样做。在 Haskell 中，你只需定义一个叫做 Maybe 的类型构造子即可：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure>


<p>它接受一个任意类型 a，然后定义一种新的类型，该类型为类型 a 的可能集合增加了一个特殊的值 Nothing。在 C++ 中，这种做法等价于这样的模板：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="k">struct</span> <span class="n">Maybe</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">T</span> <span class="n">just</span><span class="p">;</span> <span class="c1">// valid if &#39;nothing&#39; is false</span>
</span><span class='line'>    <span class="n">bool</span> <span class="n">nothing</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>（这只是一个示例而已。并非是讨论在 C++ 中 Maybe 会非常有用，C++ 有它自己的错误传播机制。）</p>

<p>这样我们就有了一种可将一种没有针对所有的值而定义的函数转化为覆盖整个值域的函数了，只不过它返回的是一种新的富类型。</p>

<p>第二个问题是这些新东西——返回 Maybe 的函数——可以复合吗？当调用者本身是更大计算的一部分的时候，它该如何处理这种函数的结果？有一件事情可以确定，这种函数的结果不能被直接传递给一个不对错误进行检测的函数——错误不能被轻易的忽略——即便这种函数很优秀。如果我们使用一个返回 Maybe<size_t> 的新函数 safe_find 来替换 find 函数，用户不能使用 substr 来调用它。因为类型不匹配。相反，safe_find 的结果必须要被解开并且进行测试（与我们之前做的差不多）。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Maybe</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">off</span> <span class="o">=</span> <span class="n">safe_find</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="sc">&#39;.&#39;</span><span class="p">);</span>
</span><span class='line'><span class="n">string</span> <span class="n">ext</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">off</span><span class="p">.</span><span class="n">nothing</span><span class="p">)</span>
</span><span class='line'>    <span class="n">ext</span> <span class="o">=</span> <span class="n">fileName</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">off</span><span class="p">.</span><span class="n">just</span><span class="p">,</span> <span class="n">fileName</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">-</span> <span class="n">off</span><span class="p">.</span><span class="n">just</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意这里发生了什么：通过更改函数的返回值类型，我们打破了函数组合的自然方式——一个函数的结果是下一个函数的输入。但是从另一角度来看，我们已经对这些函数提出了一种新的复合方式。看我如何以更好的效果将函数组合起来的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Maybe</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">foo</span><span class="p">.</span><span class="n">nothing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">just</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bar</span><span class="p">.</span><span class="n">nothing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Maybe</span><span class="o">&lt;</span><span class="n">Baz</span><span class="o">&gt;</span> <span class="n">baz</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">bar</span><span class="p">.</span><span class="n">just</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">baz</span><span class="p">.</span><span class="n">nothing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="p">...</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面第 2、4、6 行代码就是胶水，用来复合我们的新的、更能容错的函数。注意这种模板式的胶水是如何以代码的形式直白呈现的。再完美一些，我们可能更喜欢像下面这样来写代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">DO</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">z</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 DO 可以隐式的提供这样的胶水用来复合 f, g 与 h。</p>

<p>在 C++ 中要实现 DO 这样的胶水抽象会很难。我不打算折腾了。但是在 Haskell 中则别有一番天地。我们还是将上面的 C++ 代码翻译成 Haskell 代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">compose</span> <span class="n">n</span> <span class="ow">=</span>
</span><span class='line'>    <span class="kr">let</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">n</span> <span class="kr">in</span>
</span><span class='line'>    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
</span><span class='line'>    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</span><span class='line'>    <span class="kt">Just</span> <span class="n">n1</span> <span class="ow">-&gt;</span>
</span><span class='line'>        <span class="kr">let</span> <span class="n">m1</span> <span class="ow">=</span> <span class="n">g</span> <span class="n">n1</span> <span class="kr">in</span>
</span><span class='line'>        <span class="kr">case</span> <span class="n">m1</span> <span class="kr">of</span>
</span><span class='line'>        <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</span><span class='line'>        <span class="kt">Just</span> <span class="n">n2</span> <span class="ow">-&gt;</span>
</span><span class='line'>            <span class="kr">let</span> <span class="n">n3</span> <span class="ow">=</span> <span class="n">h</span> <span class="n">n2</span> <span class="kr">in</span>
</span><span class='line'>            <span class="n">n3</span>
</span></code></pre></td></tr></table></div></figure>


<p>C++ 代码中的 if 语言在 Haskell 中可以使用模式匹配（case x of）来替代。<strong>m</strong>s 是 Maybe 类型，<strong>n</strong>s 是 <strong>m</strong> 所包含的内容（假定 <strong>m</strong>s 不是 Nothing）。</p>

<p>注意代码中的级联格式特征——嵌套的条件语句或模式匹配。我们分析其中的一层。代码是从一个 Maybe 值开始的（f n 的结果），第一层胶水是第 3—5 行代码。我们将这个 Maybe 值打开并且检测其中的内容。如果结果并非错误（Just n1），就继续执行后面的函数复合代码，即 6—11 行代码。</p>

<p>如果结果是一个错误的话（模式匹配的 Nothing 分支），整个“剩余的复合代码”就会被忽略，这一点也非常重要。为了对胶水进行抽象，我们也必须对“剩余的复合代码”进行抽象。像这样的抽象，被称为“延续体”（Continuation）。我们可将延续体写为 lambda 函数（Haskell 中的 lambda 使用反斜线表示，就是希腊字母中的 λ 断了一条腿）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">\</span> <span class="n">n1</span> <span class="ow">-&gt;</span>
</span><span class='line'>    <span class="kr">let</span> <span class="n">m1</span> <span class="ow">=</span> <span class="n">g</span> <span class="n">n1</span> <span class="kr">in</span>
</span><span class='line'>    <span class="kr">case</span> <span class="n">m1</span> <span class="kr">of</span>
</span><span class='line'>    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</span><span class='line'>    <span class="kt">Just</span> <span class="n">n2</span> <span class="ow">-&gt;</span>
</span><span class='line'>        <span class="kr">let</span> <span class="n">n3</span> <span class="ow">=</span> <span class="n">h</span> <span class="n">n2</span> <span class="kr">in</span>
</span><span class='line'>        <span class="n">n3</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里有个技巧：我们可以将胶水抽象为一个（高阶）函数，它接受一个 Maybe 值和一个延续体。我们称这个新的函数为 bind，利用它重写 compose 函数如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">compose</span> <span class="n">n</span> <span class="ow">=</span>
</span><span class='line'>    <span class="kr">let</span> <span class="n">m</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">n</span> <span class="kr">in</span>
</span><span class='line'>    <span class="c1">-- the first argument is m, the second is the whole continuation</span>
</span><span class='line'>    <span class="n">bind</span> <span class="n">m</span> <span class="p">(</span><span class="nf">\</span><span class="n">n1</span> <span class="ow">-&gt;</span>
</span><span class='line'>                <span class="kr">let</span> <span class="n">m1</span> <span class="ow">=</span> <span class="n">g</span> <span class="n">n1</span> <span class="kr">in</span>
</span><span class='line'>                <span class="kr">case</span> <span class="n">m1</span> <span class="kr">of</span>
</span><span class='line'>                <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>
</span><span class='line'>                <span class="kt">Just</span> <span class="n">n2</span> <span class="ow">-&gt;</span>
</span><span class='line'>                    <span class="kr">let</span> <span class="n">n3</span> <span class="ow">=</span> <span class="n">h</span> <span class="n">n2</span> <span class="kr">in</span>
</span><span class='line'>                    <span class="n">n3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>bind 函数的实现如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">bind</span> <span class="n">m</span> <span class="n">f</span> <span class="ow">=</span>
</span><span class='line'>    <span class="kr">case</span> <span class="n">m</span> <span class="kr">of</span>
</span><span class='line'>    <span class="kt">Nothing</span> <span class="ow">-&gt;</span> <span class="kt">Nothing</span>  <span class="c1">-- bypass the continuation</span>
</span><span class='line'>    <span class="kt">Just</span> <span class="n">n</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">n</span>       <span class="c1">-- pass n to the continuation</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者更加紧凑一些：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">bind</span> <span class="kt">Nothing</span> <span class="n">cont</span>  <span class="ow">=</span> <span class="kt">Nothing</span>
</span><span class='line'><span class="nf">bind</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">n</span><span class="p">)</span> <span class="n">cont</span> <span class="ow">=</span> <span class="n">cont</span> <span class="n">n</span>
</span></code></pre></td></tr></table></div></figure>


<p>图 6 展示了整个代码的变换。 f n 的结果是一个 Maybe 值，它被传递给采用蓝色盒子表示的 bind 函数，在 bind 内部，Maybe 值被解开，如果所得的值是 Nothing，那么就什么都不发生；如果值是 Just n1，剩余的代码，即延续体会被使用 n1 作为参数值而调用。延续体本身可以使用 bind 进行重写。最终的延续体称为 return，后文再对它进行解释。</p>

<p style="text-align:center;"><img src="http://ghacker.github.com/images/posts/monad-for-curious-programmer-06.gif" title="函数复合" alt="图 6. 返回 Maybe 值的函数的复合"></p>


<p>图 6 中的蓝色盒子，bind 的位置在 Maybe 参数值与延续体之间，这暗示这中缀表示可能会更合适。的确是这样，在 Haskell 中 bind 是使用中缀操作符 >>= 来表示的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kt">Nothing</span>  <span class="o">&gt;&gt;=</span> <span class="n">cont</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</span><span class='line'><span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="o">&gt;&gt;=</span> <span class="n">cont</span> <span class="ow">=</span> <span class="n">cont</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>（等号的左侧是位于两个参数值【实际上是模式】之间的操作符，右侧是函数体）我们可以将这个 bind 函数的类型表示为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="o">&gt;&gt;=</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>它表示接受一个 Maybe a 和一个从 a 到 Maybe b 的函数（即我们的延续体），然后返回一个 Maybe b。在处理高阶函数时，我发现类型签名尤为有用；因此我经常使用它们来株式我的 C++ 元代码。</p>

<p>使用 >>= 重写 compose 函数如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">compose1</span> <span class="n">n</span> <span class="ow">=</span>
</span><span class='line'>    <span class="n">f</span> <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">n1</span> <span class="ow">-&gt;</span>
</span><span class='line'>        <span class="n">g</span> <span class="n">n1</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">n2</span> <span class="ow">-&gt;</span>
</span><span class='line'>            <span class="n">h</span> <span class="n">n2</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">n3</span> <span class="ow">-&gt;</span>
</span><span class='line'>                <span class="n">return</span> <span class="n">n3</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在到了解释函数末尾那个神秘的 return 的时间了。它当然不是表示从函数中返回一个值那样的关键字。它是一个函数，接受一个类型为 a 的参数值然后将其转化为一个 Maybe a 值：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">return</span> <span class="n">n</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="n">n</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们之所以需要 return 是因为 compose 的结果是一个 Maybe 值。如果 compose 中的任何一个函数都返回 Nothing，那么 compose 也会返回 Nothing（这是 >>= 的定义决定的）。只有在全部函数都成功的发生了作用之时，我们才应用 return 获得正确的结果 n3。return 将 n3 变为 Just n3，这宣示了计算是成功的，并且封装了最终的结果为 Maybe 类型的值。</p>

<p>你可能认为使用 return 而不是直接使用 Just n3 有点太折腾了，事实上这样做是有道理的。一个理由是可以将直接访问 Maybe 的实现隐含起来。另一个理由是这种方式适用于处理 Maybe 之外的其他情况。</p>

<h3>Maybe 单子</h3>

<p>Maybe 与单子有什么关系？可以从一个更加宽泛的视角来看前面我们做过的事情。</p>

<p>前面我们是从一种行为不太像函数的计算开始的——即它的定义并非针对全部的参数值。我们已经发现了一种聪明的方式，通过增强其返回值的类型而将其转化为函数。像这样的类型增强可以表示为类型构造子。</p>

<p>从范畴论的视角来看，定义一个类型构造子，实现从类型到类型的映射，这已经完成了自函子的一半工作。剩下的工作就是实现函数（态射）的映射。对于任何可将类型 a 的值映射为类型 b 的值的函数，我们需要一个与之对应的函数，它可以作用于被增强的类型。在 Haskell 中，函数到函数的映射可以表示为高阶函数。如果这种映射是自函子的一部分，那么对应的高阶函数被称为 fmap。</p>

<p>假设我们有一个类型构造子 M，它可以构造类型 a 的增强类型 M a。函数 fmap 的签名可表示为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">fmap</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">M</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span> <span class="n">b</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>它将一个从 a 到 b 的函数映射为从 M a 到 M b 的函数。对于 Maybe 而言，我们已经知道了它的类型构造子部分，关于它的 fmap 下面便会有讲。</p>

<p>让我们回到那个体现为返回一个增强类型的函数上，其类型签名一般为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">f</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为我们关注的是计算的复合性，我们需要一种方法可将这些增强的函数粘合到一起。在粘合的过程中，我们必须对增强类型的值进行检测并作出决断，例如判断是否继续执行剩余的计算或者终止。因此具有一般性的 bind 操作必须接受两个参数值：之前的增强函数的结果与剩余计算——一个延续体：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">bind</span> <span class="ow">::</span> <span class="kt">M</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">M</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你足够斜眼的话，便可以发现 bind 与 fmap 之间的相似性。</p>

<p>可以这样认识 bind 与 fmap 之间的相似性：想像一下你向 bind 提供了第二个参数值，那个延续体。这样便余下一个类型为 M a 的自由参数，从而便构成一个从 M a 到 M b 的函数（这个不是严格的丘奇化，因为我们正在固定第二个参数值而不是第一个，但是思想是一致的）。这个从 M a 到 M b 的函数恰恰是 fmap 签名的右半部分。这样来看，bind 实际上是将函数映射为函数：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">M</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span> <span class="n">b</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>左侧的函数是一个延续体，右侧的那个是 bind 协同第二个参数值（那个延续体）所构成的函数。</p>

<p>因此 bind 函数的签名颇为类似 fmap，但是还不够。好在我们的装备种还有一个函数族，那个多态的 return。return 的签名是：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用 bind 与 return，我们可以提升任何函数 f：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">f</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>使之成为函数 g：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">g</span> <span class="ow">::</span> <span class="kt">M</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">M</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是一个通过 f, bind 与 return 定义函数 g 的魔幻公式：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">g</span> <span class="n">ma</span> <span class="ow">=</span> <span class="n">bind</span> <span class="n">ma</span> <span class="p">(</span><span class="n">return</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用中缀表示法可写为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">g</span> <span class="n">ma</span> <span class="ow">=</span> <span class="n">ma</span> <span class="o">&gt;&gt;=</span> <span class="p">(</span><span class="n">return</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种将 f 化为 g 的映射就是我们对 fmap 的定义。当然，fmap 必须服从一些定律，特别是它必须保持函数复合性以及与 unit 交互的正确性。这些定律主要体现为与 bind 和 return 相关的一些条件，在此我不打算讨论它们。</p>

<p>现在只要单子具有两个组成部分：unit 与 join，那么我们便可重现函子。显然 return 只是 unit 的化名，对于任意类型，它以最自然的方式将这种类型的值提升为一个富类型的值（顺便说一下，“自然”这个词在范畴论中有一个非常精确的意义；unit 与 join 都是函子 (M, fmap) 的自然变换）。</p>

<p>为了重现 join，先看一下在 Haskell 中它的类型签名：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">join</span> <span class="ow">::</span> <span class="kt">M</span> <span class="p">(</span><span class="kt">M</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">M</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure>


<p>它将类型构造子坍缩了一层。对于 Maybe 而言，它应当将双层 Maybe 映射为单层 Maybe，即它应当将 Just (Just x) 映射为 Just x，其他值都映射为 Nothing。其实有一种更加通用的方式来定义 join 函数，使用 bind 与单位函数即可实现：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">join</span> <span class="ow">::</span> <span class="kt">M</span> <span class="p">(</span><span class="kt">M</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">M</span> <span class="n">a</span>
</span><span class='line'><span class="nf">join</span> <span class="n">mmx</span> <span class="ow">=</span> <span class="n">mmx</span> <span class="o">&gt;&gt;=</span> <span class="n">id</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们所做的是将类型为 M (M a) 的值绑定到 id 函数。这个 id 函数作用于 M a 值，返回是相同的 M a 值。你完全可以确信这些类型签名是匹配 bind 的签名的（见附录）；而且这个定义作用于 Maybe 时，会产生正确的结果。</p>

<p>总结一下：在这里我们所做的就是展现了具备 bind 与 return 的 Maybe 是范畴论意义中的单子。实际上，我们展现了更为一般的东西：由类型构造子与 bind、return 这两个服从一些定律的函数所构成的所有的三元组，每一个都定义了一个单子。在范畴论中，这个三元组被称为 Kleisli 三元组，可当作单子的另一种定义。</p>

<h3>语法糖</h3>

<p>现在你只是见识了 Maybe 的例子，可能看上去我们是拽出一只单子迫击炮灭掉一只蚊子。不过你以后会看到，披着不同伪装的同样的模式在大量的场合不断重现。实际上这在函数式语言中相当普遍，因此需要构建的语法糖。在 Haskell 中，这种语法糖叫 do 表达式。让我们倒一下车，看看 compose 的实现：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">compose</span> <span class="n">n</span> <span class="ow">=</span>
</span><span class='line'>    <span class="n">f</span> <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">n1</span> <span class="ow">-&gt;</span>
</span><span class='line'>        <span class="n">g</span> <span class="n">n1</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">n2</span> <span class="ow">-&gt;</span>
</span><span class='line'>            <span class="n">h</span> <span class="n">n2</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span><span class="n">n3</span> <span class="ow">-&gt;</span>
</span><span class='line'>                <span class="n">return</span> <span class="n">n3</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是以 do 表达式写出的等价代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">compose</span><span class="p">(</span><span class="n">Foo</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="n">n1</span><span class="p">);</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">n3</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">n2</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">n3</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>看上去伪装的很像一种命令式程序。下面是一个 C++ 的版本（假定 f 接受的是一个指向 Foo 值的指针，h 返回一个整型数）。</p>

<p>呃，你还需要做一些事情，就是你该如何调用它：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">try</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">compose</span><span class="p">(</span><span class="n">pFoo</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">catch</span><span class="p">(...)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// error handling</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 C++ 中，事实上你可以得到相同的函数性，只是并非通过修改返回类型，而是通过抛出异常而已（看到这些 C++ 代码，现在你可以发出第一声惊呼了，“嘿，看起来像是单子！”）</p>

<p>如果我们的 Haskell 示例中一旦任何函数报错（抛出异常），compose 剩下的计算便会被忽略。你可以认为 C++ 异常要比 Maybe 单子更强大，这种认识没有错。但是要知道我还没有向你展示 Error 单子和 Exception 单子呢。</p>

<p>Haskell 的 Exception 单子胜出 C++ 异常之处在于类型检测。还记得向 C++ 类型系统添加异常规范的悲催经历么（Java 一样悲催）？C++ 标准如是说：</p>

<blockquote><p>一个实现不应当因为一个表达式在被执行时抛出或者可能抛出一个不被这个实现所包含的函数允许的异常而拒绝它。</p></blockquote>

<p>换句话说，C++ 的异常规范是善意的注释。Haskell 中却不是这样！如果一个函数返回一个 Maybe 或 Exception 值，它便编程类型签名的一部分，无论是在应用时还是在函数的定义时都会被检测。欺骗是行不通的，句号。</p>

<p>其实 Haskell 与 C++ 在异常处理方面最主要的区别是 do 表达式适用于所有单子，而 C++ 那个巧妙的 try/catch 语法只适用于异常。</p>

<p>阅读 Haskell 的单子代码时需要注意，虽然在用法上有些相似，但左向箭头并非赋值。左侧的标示符对应延续体（也就是 do 块余下的部分）的参数值。它是右侧表达式所得结果解开后得到的值。这种解包行为总是在 bind 内部进行的。</p>

<h3>非确定计算</h3>

<p>前面，我曾通过定义函子与两个函数族的方式介绍过列表单子。这个函子的类型构造子部分可将任何类型 a 映射为 [a]。作用于函数的部分（现在我们知道了，这就是 fmap，不过对于列表而言它是 map）可将这个函数作用于列表中的每个元素。unit 与 join 都是多态函数，unit 被定义为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">unit</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>join 函数就是 concat 函数。</p>

<p>现在我可以告诉你，列表单子提供了实现非确定计算的解决方案。想像一下，解析一个不确定的语法。对于相同的输入而言结果可能是多个候选解析树。</p>

<p>这些计算类型可以通过让函数返回可能结果的列表来模拟。我们可以故伎重演：一个非确定解析器所返回的任何结果（例如一个解析树类型），都会被转化为一个增强的类型（一个解析树列表）。</p>

<p>我们已经见识过列表单子的范畴论构造，但是这里我们面对的问题有些不同：如何将返回列表的函数串联起来。我们知道，这需要定义 bind 函数。它的签名在这种情况下是：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">bind</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">])</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>它接受一个列表（前一个函数的结果）和一个延续体，(a -> [b])，结果必须要产生一个列表。连续体显然是要作用于所输入列表中每一个元素的。但是优于延续体也产生一个列表，我们最终得到的是列表的列表。为了得到单层列表，只需消除子列表即可。基于此，bind 的实现如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">xs</span> <span class="o">&gt;&gt;=</span> <span class="n">cont</span> <span class="ow">=</span> <span class="n">concat</span> <span class="p">(</span><span class="n">map</span> <span class="n">cont</span> <span class="n">xs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>延续体作用于所输入列表中每个元素，是通过 map 来实现的。</p>

<p>我们可以使用 join 与 fmap 来定义 bind，这是巧合吗？肯定不是。单子的函子定义转换为 Klesisli 三元组有一个通用的公式：</p>

<blockquote><p>接受函子的对象映射部分（类型构造子）。</p>

<p>定义 bind 函数：<code>bind x f = join ((fmap f) x))</code>，其中 fmap 是函子的态射映射部分。</p>

<p>将 unit 定义为 return</p></blockquote>

<p>现在我们知道了如何在这两种定义之间进退了。</p>

<p>就像在 Maybe 的情况一样，我们可以对返回列表的函数应用 do 表达式：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">toss2Dice</span> <span class="ow">=</span> <span class="kr">do</span>
</span><span class='line'>    <span class="n">n</span> <span class="ow">&lt;-</span> <span class="n">tossDie</span>
</span><span class='line'>    <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">tossDie</span>
</span><span class='line'>    <span class="n">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">++</span> <span class="n">m</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中 tossDie 返回一个骰子投掷后所有可能的结果构成的列表，toss2Dice 返回的是骰子投掷两次所得的所有结果的总和所构成的列表。</p>

<p>有趣的现象是列表单子与列表解析式的相关性。上面的例子等价于：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">toss2Dice</span> <span class="ow">=</span> <span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">m</span> <span class="o">|</span> <span class="n">n</span> <span class="ow">&lt;-</span> <span class="n">tossDie</span><span class="p">,</span> <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">tossDie</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>总结</h3>

<p>很大一类计算都是以非函数式的方式将输入转化为输出。其中有许多可以表示为返回增强类型的结果的函数。结果的增强可采用类型构造子的形式表示。这种类型构造子定义了单子的第一个构成部分。</p>

<p>因为计算必须是可复合的，所以我们需要一种可以复合增强的函数的方式。这就引入了单子的第二个构成部分，即 bind 高阶函数族。</p>

<p>最后，我们需要构造可以返回增强类型的函数，为了解决这个问题，我们需要单子的第三个构成部分，return 函数族。它们可以将常规值转化为增强类型的相应的值。</p>

<h2>第三部分</h2>

<h3>函数、状态与副作用</h3>

<p>有这么一个问题：在函数式语言中，每次使用相同的参数值调用一个函数时，它必须要返回同样的结果。事实上，如果编译器检测到这样的情况，它会记住第一次函数调用的返回结果，并忽略后续的调用。但是，对于依赖状态的计算，可能对于相同的参数值调用会每次返回不同的结果。例如程序要访问或修改一些全局或静态变量，这就是带有“副作用”的函数。极端的情况下，有些计算可能就是为了副作用而被执行的，并不打算返回任何结果。</p>

<p>这种事情即便是在命令式编程中也是非常烦人的问题。全局变量的使用是特别不被推荐的。更好的解决方案是将状态封装起来，然后显式的传递给要使用它的函数。在面向对象语言中，作为一种语法糖，部分状态可以作为隐含的“this”或“self”参数值传递给函数。甚至有一种语法可以将这样的函数复合起来，像下面的 JavaScript 代码片段：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">with</span> <span class="p">(</span><span class="n">document</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">var</span> <span class="n">t</span> <span class="ow">=</span> <span class="n">title</span><span class="p">;</span>
</span><span class='line'>  <span class="n">write</span> <span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="s">&quot; and more&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中，title 与 write 分别是 document 对象的一个属性与一个方法（如果你带上单子眼镜的话，你看到的像是 do 语法块的一种东西）。</p>

<p>在函数式语言中，我们有更多的限制：我们不能够修改任何数据。有一种标准的方法克服这一限制：不要修改数据，而是要创建一个可修改的副本。如果语言支持以引用来替代副本的智能数据结构的话，这样做甚至不需要付出太多代价。Haskell 中列表的大部分操作都是采用这种方式进行优化的。甚至有一种语言—Clojure 的整个核心都是基于“持久”的数据结构而构建的，这种数据结构看上去似乎不可被修改，实际上在后台却进行了大量的内存共享处理。在编写并行程序时，数据的不可修改性（Immutability）是一项非常有诱人的特性：不需要同步即可访问不可修改的数据。</p>

<p>总而言之，将依赖于状态的计算翻译为函数式语言的方法就是使用可以显式接受状态（封装在某种数据结构中）并且返回可能被修改的状态以及常规返回值的函数。例如，下面这样的 C++ “函数”：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="kt">int</span> <span class="nf">pop</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="n">glob</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
</span><span class='line'>    <span class="n">glob</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个函数操作着一个类型为 std::vector<int> 的全局向量 glob，将其翻译为 Haskell 函数：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">pop</span> <span class="p">(</span><span class="kt">ST</span> <span class="n">lst</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">ST</span> <span class="p">(</span><span class="n">tail</span> <span class="n">lst</span><span class="p">),</span> <span class="n">head</span> <span class="n">lst</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个 Haskell 函数操作着一个状态值，该值的类型为 Stack：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">newtype</span> <span class="kt">Stack</span> <span class="ow">=</span> <span class="kt">ST</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>值构造子 <code>ST</code> 可从一个整型数值列表创建一个 Stack 类型的值。这个值构造子也可用于模式匹配，像 pop 函数的参数那样。head 函数返回列表的第一个元素，tail 函数返回去除了第一个元素的列表。</p>

<p>pop 函数的签名是典型的用于处理状态的函数签名：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">top</span><span class="ow">::</span> <span class="kt">Stack</span><span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Stack</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种类型的函数通常被称为“动作（Action）”。</p>

<p>对于这种模式的函数，存在两个问题：（1）它太丑了；（2）缺乏单子风格。上面的示例，采用 C++ 代码表示的原始的计算是不接受参数并返回一个整型数，而转化为函数式语言时则变成要接受一个状态值然后再返回一个整型值与状态值的复合值。现在还不清楚该如何将这样的函数绑定起来并对它们应用方便的 do 语法。</p>

<p>我们正走在正确的道路上。现在只需要将视野再放宽一些：将动作的构建与执行隔离开来。这只需要构建一个函数，使其返回一个动作，这样的函数我们称之为“单子函数”。因为动作是一个函数，我们要处理的是返回函数的函数，即高阶函数。</p>

<p>我们的目标就是寻找一种方式，用于将一些单子函数复合为更大的单子函数。一个复合的单子函数可以返回一个复合的动作。然后基于一个状态执行这一动作，从而得到结果。</p>

<p>上述方式更加复合单子之道。我们可以从一个通用的状态计算开始，该计算接受一个类型为 a 的参数值，返回一个类型为 b 的参数值，我们要将其转化为一个单子函数，使得该函数接受类型 a 的值并返回一个以 b 为基础的增强类型的值，只不过这一次增强类型是函数类型——动作而已。一般情况下，一个动作是接受一个状态（类型为 S 的值）并返回一个由状态与类型 b 的值所构成的二元组的函数，其签名如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kt">S</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">S</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就是状态单子的第一要素——类型构造子：对于任意类型 t，它定义了一种新的类型：对于给定的状态计算类型为 t 的值的一个动作。这种类型构造子是状态单子的一部分。在通往状态单子的正式定义之前，我们需要热热身。</p>

<h3>单子计算器</h3>

<p>基于状态的计算有一个完美的示例：一个基于状态的计算器。在该示例中，状态可表示为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">newtype</span> <span class="kt">Calc</span> <span class="ow">=</span> <span class="kt">Calc</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中隐含了一个整型数值列表——计算器栈。</p>

<p>首先，我们定义一个单子函数（返回动作的函数），使之从计算器栈中弹出一个元素。这个是返回函数的函数，所以我们需要使用匿名函数来实现：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">popCalc</span> <span class="ow">=</span>
</span><span class='line'>    <span class="nf">\</span><span class="p">(</span><span class="kt">Calc</span> <span class="n">lst</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Calc</span> <span class="p">(</span><span class="n">tail</span> <span class="n">lst</span><span class="p">),</span> <span class="n">head</span> <span class="n">lst</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>匿名函数几乎是上面 pop 函数的翻版。注意 popCalc 函数不接受任何参数，但是它返回一个可以接受一个计算器状态作为参数值然后返回这个计算器状态与计算结果（计算器栈顶端的值）打包的值。换句话说，popCalc 返回的是一个承诺：一旦计算器栈可用之时，它便会返回栈顶的值。</p>

<p>使用 popCalc 的方法是：首先，调用它并记录其返回的动作；然后创建一个计算器状态（带有一个非空栈）；继而将动作应用于计算器状态，对于所得结果可以使用模式匹配来获取最终用计算结果。具体过程如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">f</span> <span class="ow">=</span> <span class="n">popCalc</span>
</span><span class='line'><span class="o">&gt;</span> <span class="kr">let</span> <span class="n">calc</span> <span class="ow">=</span> <span class="kt">Calc</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
</span><span class='line'><span class="o">&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">calc&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">calc</span>
</span><span class='line'><span class="o">&gt;</span> <span class="n">x</span>
</span><span class='line'><span class="mi">3</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面我们采用同样的思想实现 pushCalc 函数：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">pushCalc</span> <span class="n">n</span> <span class="ow">=</span>
</span><span class='line'>    <span class="nf">\</span><span class="p">(</span><span class="kt">Calc</span> <span class="n">lst</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Calc</span> <span class="p">(</span><span class="n">n</span><span class="kt">:</span><span class="n">lst</span><span class="p">),</span> <span class="nb">()</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意 pushClac 所产生的匿名函数返回的是一个被修改了的计算器状态以及一个类型为 unit 的特殊的值 ()——void 的 Haskell 对等物——的打包结果。这个函数如果使用命令式语言来实现，只能返回 void 并且通过副作用的方式进行工作。还应当注意到这个匿名函数实际上是一个闭包：它捕获外部变量 n 留待后续使用。</p>

<p>最后，我们需要一个函数来执行一些计算，毕竟我们是要实现一个计算器。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">addCalc</span> <span class="ow">=</span>
</span><span class='line'>    <span class="nf">\</span><span class="p">(</span><span class="kt">Calc</span> <span class="n">lst</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">b</span><span class="kt">:</span><span class="n">rest</span><span class="p">)</span> <span class="ow">=</span> <span class="n">lst</span>
</span><span class='line'>                   <span class="kr">in</span>
</span><span class='line'>                       <span class="p">(</span><span class="kt">Calc</span> <span class="p">((</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span><span class="kt">:</span><span class="n">rest</span><span class="p">),</span> <span class="nb">()</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中我使用了模式 (a:b:rest) 来匹配计算器栈，以此来获取栈顶两个元素。被修改后的计算器状态，栈顶是原栈顶两个元素的和。</p>

<p>我们可以使用这些函数的复合来实现更为复杂的操作，例如将两个数相加。下面的代码跟 Rube Goldberg 机有一拼：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">add</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span>
</span><span class='line'>    <span class="kr">let</span> <span class="n">pux</span> <span class="ow">=</span> <span class="n">pushCalc</span> <span class="n">x</span> <span class="c1">-- 许诺将 x 压入栈</span>
</span><span class='line'>        <span class="n">puy</span> <span class="ow">=</span> <span class="n">pushCalc</span> <span class="n">y</span> <span class="c1">-- 许诺从栈中弹出 y</span>
</span><span class='line'>        <span class="n">axy</span> <span class="ow">=</span> <span class="n">addCalc</span>    <span class="c1">-- 许诺对栈顶两个元素求和</span>
</span><span class='line'>        <span class="n">pp</span> <span class="ow">=</span> <span class="n">popCalc</span>     <span class="c1">-- 许诺从栈顶弹出结果</span>
</span><span class='line'>        <span class="n">calc</span> <span class="ow">=</span> <span class="kt">Calc</span> <span class="kt">[]</span>   <span class="c1">-- 需要一个计算器状态</span>
</span><span class='line'>        <span class="p">(</span><span class="n">calc1</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pux</span> <span class="n">calc</span>  <span class="c1">-- 真的将 x 压入栈</span>
</span><span class='line'>        <span class="p">(</span><span class="n">calc2</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">puy</span> <span class="n">calc1</span> <span class="c1">-- 真的将 y 弹出栈</span>
</span><span class='line'>        <span class="p">(</span><span class="n">calc3</span><span class="p">,</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">axy</span> <span class="n">calc2</span> <span class="c1">-- 真的对栈顶两个元素求和</span>
</span><span class='line'>        <span class="p">(</span><span class="kr">_</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">=</span> <span class="n">pp</span> <span class="n">calc3</span>      <span class="c1">-- 真的弹出求和结果</span>
</span><span class='line'>    <span class="kr">in</span>
</span><span class='line'>        <span class="n">z</span>  <span class="c1">-- return the result</span>
</span></code></pre></td></tr></table></div></figure>


<p>实际上我们真正想做的是将小的动作组合为大的动作。对于这个目的，我们需要定义 bind 函数，在这种情况下，其签名应该是：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">bind</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Calc</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Calc</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span> <span class="ow">-&gt;</span>        <span class="c1">-- 动作</span>
</span><span class='line'>        <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Calc</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Calc</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="ow">-&gt;</span>  <span class="c1">-- 延续体</span>
</span><span class='line'>        <span class="p">(</span><span class="kt">Calc</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Calc</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>           <span class="c1">-- 新动作</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个签名看起来要比 Maybe 单子的 bind 函数的签名复杂的多，但是这仅仅是因为前者的增强类型其本身也是一个函数类型，其他方面则是相同的：bind 接受一个动作和一个延续体，然后返回一个新动作。这种情况中的延续体接受一个类型为 a 的参数值（要被第一个动作计算的值），然后返回一个复合的动作。</p>

<p>事实上，如果我们采用类型别名的形式定义动作：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">type</span> <span class="kt">Action</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Calc</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Calc</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么 bind 函数的签名可以缩写为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">bind</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Action</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="kt">Action</span> <span class="n">b</span><span class="p">))</span> <span class="ow">-&gt;</span>  <span class="p">(</span><span class="kt">Action</span> <span class="n">b</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面来看如何实现 bind。因为 bind 的结果是一个动作，那么它必须返回一个签名合适的匿名函数。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">bind</span> <span class="n">act</span> <span class="n">cont</span> <span class="ow">=</span>
</span><span class='line'>    <span class="nf">\</span><span class="n">calc</span> <span class="ow">-&gt;</span> <span class="o">...</span> <span class="err">生成</span> <span class="p">(</span><span class="kt">Calc</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="err">元组</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>bind 是用于复合动作 act 与延续体 cont 的，因此它应当首先对 clac 应用 act：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">let</span> <span class="p">(</span><span class="n">calc&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">act</span> <span class="n">calc</span>
</span></code></pre></td></tr></table></div></figure>


<p>结果是一个元组 (clac&#8217;, v)，其中 v 是类型为 a 的值，这正是延续体所期望的参数值，因此紧接着就是应用延续体：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">act&#39;</span> <span class="ow">=</span> <span class="n">cont</span> <span class="n">v</span>
</span></code></pre></td></tr></table></div></figure>


<p>延续体的结果是一个新动作。这个新动作可以被执行，即应用于新的计算器状态</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">act&#39;</span> <span class="n">clac&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>从而产生所期望的结果——类型为 (Clac, b) 的元组。</p>

<p>因此 bind 完整的代码是：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">bind</span> <span class="n">act</span> <span class="n">cont</span> <span class="ow">=</span>
</span><span class='line'>    <span class="nf">\</span><span class="n">calc</span> <span class="ow">-&gt;</span>
</span><span class='line'>        <span class="kr">let</span> <span class="p">(</span><span class="n">calc&#39;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">act</span> <span class="n">calc</span>
</span><span class='line'>            <span class="n">act&#39;</span> <span class="ow">=</span> <span class="n">cont</span> <span class="n">v</span>
</span><span class='line'>        <span class="kr">in</span>
</span><span class='line'>            <span class="n">act&#39;</span> <span class="n">calc&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了完善状态单子的构造，我们还需要定义 return 函数，其签名为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">return</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Action</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure>


<p>该函数的实现是相当直观的。它接受值 v 然后返回一个可以返回这个值的承诺：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">return</span> <span class="n">v</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">calc</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">calc</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>敏锐的读者可能会注意到这个 return 函数不依赖于类型 Calc 的什么特性的。对于任何表示状态的任何类型，它都可以工作。这样的话，我们就可以构造一个通用的状态单子了。基于状态的计算器就是这种单子的一个实例。</p>

<p>将 bind 函数采用中缀操作符的形式表示并不困难，将计算器状态转化 Haskell 编译器可以识别的单子也不困难。这样，add 函数的相关部分就可以写成 do 表达式的形式：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">add</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="kr">do</span>
</span><span class='line'>    <span class="n">pushCalc</span> <span class="n">x</span>
</span><span class='line'>    <span class="n">pushCalc</span> <span class="n">y</span>
</span><span class='line'>    <span class="n">addCalc</span>
</span><span class='line'>    <span class="n">r</span> <span class="ow">&lt;-</span> <span class="n">popCalc</span>
</span><span class='line'>    <span class="n">return</span> <span class="n">r</span>
</span></code></pre></td></tr></table></div></figure>


<p>上述代码如果进行脱糖的话，就可以变成级联嵌套的匿名函数式：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">add</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span>
</span><span class='line'>  <span class="n">bind</span> <span class="p">(</span><span class="n">pushCalc</span> <span class="n">x</span><span class="p">)</span>
</span><span class='line'>       <span class="p">(</span><span class="nf">\</span><span class="nb">()</span> <span class="ow">-&gt;</span> <span class="n">bind</span> <span class="p">(</span><span class="n">pushCalc</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">(</span><span class="nf">\</span><span class="nb">()</span> <span class="ow">-&gt;</span> <span class="n">bind</span> <span class="n">addCalc</span>
</span><span class='line'>                                 <span class="p">(</span><span class="nf">\</span><span class="nb">()</span> <span class="ow">-&gt;</span> <span class="n">bind</span> <span class="n">popCalc</span>
</span><span class='line'>                                              <span class="p">(</span><span class="nf">\</span><span class="n">z</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="n">z</span><span class="p">))))</span>
</span></code></pre></td></tr></table></div></figure>


<p>你在 Haskell 程序中通常看不到这样的表达式，只不过我想超越 Haskell 的范畴。我的目标是能够将其与 C++ 联系起来，这种形式最方便进行语义转换。</p>

<p>因此我们不辞劳苦分析一下上面的代码。我们首先将第一个动作 (pushCalc x) 绑定到余下的代码。余下的代码是一个巨大的匿名函数。为了让这两部分匹配，他们的类型必须匹配。pushCalc 动作所生成的值是 void，因此其类型是 Action ()。因此它所绑定的匿名函数的类型也必须是接受 void 值的，其形式为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">\</span><span class="nb">()</span> <span class="ow">-&gt;</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>匿名函数体是又是一个 bind，以此类推，直至到达我们最感兴趣的部分——popCalc。</p>

<p>popCalc 动作可以计算一个值：其签名为 Action Int。这个值被传入 popCalc 所绑定的那个匿名函数，因此最后的那个匿名函数会接受一个 Int 类型的参数值 z。最后这个值被 return 函数封装到一个动作中。</p>

<p>这种脱糖后的代码阐释了 Haskell 单子方法的全貌。Haskell 是一种惰性语言：只有最终目标真正需要的时候才会进行求值。还有，对于一些独立的事务进行求值时，它会以一种随意的次序进行。因此如果有可能实现 push 与 pop 的 Haskell 版本，我们会遇到两个问题：push 可能永远都不会被求值，因为它没有产生任何结果，甚至它可能会在 pop 之后被求值。单子的 bind 可以通过引入显式的数据依赖性强制动作的求值次序。如果在 bind 链中 pop 尾随着 push，那么 pop 不可能会先于 push 求值，因为它的参数值是 push 返回的计算器状态。它们两个被数据依赖性连接了起来，这种机制在 do 表达式中是不好看到的。</p>

<h3>总结</h3>

<p>从编程的视角来看，状态单子是非常有趣的一种模式。其意不在于处理什么，而在于创建一种可在后续中执行（甚至是可能多次执行）的动作。单子的框架提供了一套设施，例如动作的复合机制以及可以让代码看起来更自然的 do 表达式。状态单子有一种有趣的变种，称为 IO 单子，在 Haskell 语言中它被用于处理输入与输出的任务。</p>

<p>命令式语言中有许多种模式或多或少的呈现出状态单子的形式。例如在 OO 世界中你可能会遇到非常有用的<a href="http://en.wikipedia.org/wiki/Command_pattern">命令模式</a>。你可以使用<a href="http://en.wikipedia.org/wiki/Composite_pattern">复合模式</a>来“绑定”命令对象。在那些支持匿名函数与闭包的语言中，例如 JavaScript、C# 以及最近的 C++，你可以直接从函数返回函数。这可能对于处理逆向控制会有帮助，这种逆向控制表现为：你返回了一个闭包并将其作为事件处理器（对于这个问题，我会再写一系列博文）。</p>

<p>其实我考虑的一个非常特殊的例子是：我曾经使用 C++ 以完全贴合单子模式的方式编程。这篇文章之后我会写这个。</p>
]]></content>
  </entry>
  
</feed>
